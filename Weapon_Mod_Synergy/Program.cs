using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Order;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using Mutagen.Bethesda.Plugins.Binary.Headers;
#pragma warning disable CA1416 

namespace Weapon_Mod_Synergy
{
    public class DefaultDamageData
    {
        public string Keyword { get; set; } = "";
        public float Damage { get; set; }
        public float Damage_WACCF { get; set; }
    }

    public class Program
    {
        static Lazy<Settings> Settings = null!;
        private static WeaponHelper? _weaponHelper;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Weapon_Mod_Synergy.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            // Initialize enabled weapon types from settings
            var enabledWeaponTypes = new Dictionary<string, WeaponSettings>();

            // Get all properties of type WeaponSettings from the Settings class
            var settingsProperties = typeof(Settings).GetProperties()
                .Where(p => p.PropertyType == typeof(WeaponSettings));

            foreach (var prop in settingsProperties)
            {
                var settings = prop.GetValue(Settings.Value) as WeaponSettings;
                if (settings != null)
                {
                    // Use the property name as the weapon type
                    enabledWeaponTypes.Add(prop.Name, settings);
                }
            }

            // Create WeaponHelper instance
            _weaponHelper = new WeaponHelper(enabledWeaponTypes, Console.WriteLine);

            // Get the list of plugins to include or exclude
            var pluginList = Settings.Value.PluginList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Get the list of ignored weapon form keys
            var ignoredWeaponFormKeys = Settings.Value.IgnoredWeaponFormKeys
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            _weaponHelper?.DebugLog("--------------------------------");
            _weaponHelper?.DebugLog("Ignored Weapons Configuration");
            _weaponHelper?.DebugLog($"Raw ignored weapons string: '{Settings.Value.IgnoredWeaponFormKeys}'");
            _weaponHelper?.DebugLog($"Number of ignored weapons: {ignoredWeaponFormKeys.Count}");
            foreach (var formKey in ignoredWeaponFormKeys)
            {
                _weaponHelper?.DebugLog($"     {formKey}");
            }
            _weaponHelper?.DebugLog("--------------------------------");

            Console.WriteLine("Plugin Processing Settings:");
            Console.WriteLine($"Filter Mode: {Settings.Value.PluginFilter}");
            Console.WriteLine("Plugin List:");
            foreach (var plugin in pluginList)
            {
                Console.WriteLine($"     {plugin}");
            }
            Console.WriteLine();

            // Get all available plugins in load order
            var availablePlugins = state.LoadOrder.PriorityOrder
                .Select(mod => mod.ModKey.FileName.String)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Check for missing plugins if we're in include mode
            if (Settings.Value.PluginFilter == PluginFilter.IncludePlugins)
            {
                var missingPlugins = pluginList.Where(p => !availablePlugins.Contains(p)).ToList();
                if (missingPlugins.Any())
                {
                    Console.WriteLine("WARNING: The following plugins were listed for inclusion but could not be found:");
                    foreach (var plugin in missingPlugins)
                    {
                        Console.WriteLine($"     {plugin}");
                    }
                    Console.WriteLine();
                }
            }

            Console.WriteLine("Processing the following plugins:");
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (shouldProcess)
                {
                    Console.WriteLine($"     {modGetter.ModKey.FileName}");
                }
            }
            Console.WriteLine();

            // Process weapons from plugins
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (!shouldProcess) continue;

                Console.WriteLine($"Processing mod: {modGetter.ModKey.FileName}");

                // Process each weapon from the current mod
                foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()
                    .Where(w => w.FormKey.ModKey == modGetter.ModKey))
                {
                    bool isSpecialWeapon = _weaponHelper?.IsSpecialWeapon(weapon) ?? false;

                    // Skip if weapon is not playable
                    if (weapon.Data?.Flags.HasFlag(WeaponData.Flag.NonPlayable) == true && !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"--------------------------------");
                        _weaponHelper?.DebugLog($"Skipping non-playable weapon: {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"--------------------------------");
                        continue;
                    }

                    // Skip if weapon uses a template
                    if (weapon.Template?.FormKey != null &&
                        !weapon.Template.FormKey.IsNull &&
                        weapon.Template.FormKey.ToString() != "Null" &&
                        !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"--------------------------------");
                        _weaponHelper?.DebugLog($"Skipping template weapon: {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"--------------------------------");
                        continue;
                    }

                    // Check if weapon should be ignored
                    var formKeyString = weapon.FormKey.ToString();
                    if (formKeyString != null && ignoredWeaponFormKeys.Contains(formKeyString) && !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"--------------------------------");
                        _weaponHelper?.DebugLog($"Ignored Weapon Found");
                        _weaponHelper?.DebugLog($"Weapon EditorID: {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"Weapon FormKey: {formKeyString}");
                        _weaponHelper?.DebugLog($"Weapon Name: {weapon.Name?.String ?? "Unknown"}");
                        _weaponHelper?.DebugLog($"Weapon Mod: {weapon.FormKey.ModKey.FileName}");
                        _weaponHelper?.DebugLog($"Skipping ignored weapon: {formKeyString}");
                        _weaponHelper?.DebugLog($"--------------------------------");
                        continue;
                    }

                    // Get weapon setting key
                    var weaponSettingKey = _weaponHelper?.GetWeaponSettingKey(weapon, state.LinkCache);
                    if (weaponSettingKey == null)
                    {
                        _weaponHelper?.DebugLog($"--------------------------------");
                        _weaponHelper?.DebugLog($"Warning: Could not determine weapon setting key for {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"--------------------------------");
                        continue;
                    }

                    // Get weapon settings
                    if (!enabledWeaponTypes.TryGetValue(weaponSettingKey, out var settings))
                    {
                        _weaponHelper?.DebugLog($"--------------------------------");
                        _weaponHelper?.DebugLog($"No settings found for weapon type: {weaponSettingKey}");
                        _weaponHelper?.DebugLog($"--------------------------------");
                        continue;
                    }

                    _weaponHelper?.DebugLog($"--------------------------------");
                    _weaponHelper?.DebugLog($"Processing weapon {weapon.EditorID} with type {weaponSettingKey}");
                    _weaponHelper?.DebugLog($"Weapon settings for {weaponSettingKey}:");
                    _weaponHelper?.DebugLog($"- Base Damage: {settings.Damage}");
                    _weaponHelper?.DebugLog($"- Reach: {settings.Reach}");
                    _weaponHelper?.DebugLog($"- Speed: {settings.Speed}");
                    _weaponHelper?.DebugLog($"- Stagger: {settings.Stagger}");
                    _weaponHelper?.DebugLog($"- Critical Damage: {settings.CriticalDamage}");
                    _weaponHelper?.DebugLog($"- Critical Damage Multiplier: {settings.CriticalDamageMultiplier}");
                    _weaponHelper?.DebugLog($"- Use Floor Division: {settings.UseFloorDivision}");

                    // Process weapon based on if it is a special weapon or not
                    if (isSpecialWeapon)
                    {
                        ProcessSpecialWeapon(weapon, state, settings);
                    }
                    else
                    {
                        ProcessWeapon(weapon, state, settings);
                    }
                }
            }
        }

        private static void ProcessSpecialWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, WeaponSettings settings)
        {
            var specialWeapons = _weaponHelper?.GetLoadedSpecialWeapons();
            if (specialWeapons == null) { _weaponHelper?.DebugLog($"No special weapons data loaded. Skipping special weapon checks."); }
            else
            {
                foreach (var specialWeapon in specialWeapons)
                {
                    if (string.IsNullOrEmpty(specialWeapon.FormKey)) continue;

                    if (FormKey.TryFactory(specialWeapon.FormKey, out var formKey) && weapon.FormKey == formKey)
                    {
                        _weaponHelper?.DebugLog($"Found special weapon match by form key: {weapon.FormKey}");
                        _weaponHelper?.DebugLog($"=== Processing Special Weapon: {weapon.EditorID} ===");
                        _weaponHelper?.DebugLog($"Base stats from settings:");
                        _weaponHelper?.DebugLog($"  - Damage: {settings.Damage}");
                        _weaponHelper?.DebugLog($"  - Speed: {settings.Speed}");
                        _weaponHelper?.DebugLog($"  - Reach: {settings.Reach}");
                        _weaponHelper?.DebugLog($"  - Stagger: {settings.Stagger}");

                        // Create a copy of the weapon for modification
                        var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
                        if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
                        {
                            _weaponHelper?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                            continue;
                        }

                        // Apply special weapon offsets
                        int specialDamageOffset = specialWeapon.DamageOffset ?? 0;
                        float speedOffset = specialWeapon.SpeedOffset ?? 0;
                        float reachOffset = specialWeapon.ReachOffset ?? 0;
                        float staggerOffset = specialWeapon.StaggerOffset ?? 0;
                        int criticalDamageOffsett = specialWeapon.CriticalDamageOffset ?? 0;
                        float criticalDamageMultiplierOffset = specialWeapon.CriticalDamageMultiplierOffset ?? 0;

                        if (Settings.Value.WACCFMaterialTiers)
                        {
                            if (specialWeapon.DamageOffsetWaccf != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF damage offset: {specialDamageOffset}");
                            }
                            if (specialWeapon.SpeedOffsetWaccf != null)
                            {
                                speedOffset = specialWeapon.SpeedOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF speed offset: {speedOffset}");
                            }
                            if (specialWeapon.ReachOffsetWaccf != null)
                            {
                                reachOffset = specialWeapon.ReachOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF reach offset: {reachOffset}");
                            }
                            if (specialWeapon.StaggerOffsetWaccf != null)
                            {
                                staggerOffset = specialWeapon.StaggerOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF stagger offset: {staggerOffset}");
                            }
                            if (specialWeapon.CriticalDamageOffsetWaccf != null)
                            {
                                criticalDamageOffsett = specialWeapon.CriticalDamageOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF critical damage offset: {criticalDamageOffsett}");
                            }
                            if (specialWeapon.CriticalDamageMultiplierOffsetWaccf != null)
                            {
                                criticalDamageMultiplierOffset = specialWeapon.CriticalDamageMultiplierOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF critical damage multiplier offset: {criticalDamageMultiplierOffset}");
                            }
                        }

                        if (Settings.Value.Artificer)
                        {
                            if (specialWeapon.DamageOffsetArtificer != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer damage offset: {specialDamageOffset}");
                            }
                            if (specialWeapon.SpeedOffsetArtificer != null)
                            {
                                speedOffset = specialWeapon.SpeedOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer speed offset: {speedOffset}");
                            }
                            if (specialWeapon.ReachOffsetArtificer != null)
                            {
                                reachOffset = specialWeapon.ReachOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer reach offset: {reachOffset}");
                            }
                            if (specialWeapon.StaggerOffsetArtificer != null)
                            {
                                staggerOffset = specialWeapon.StaggerOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer stagger offset: {staggerOffset}");
                            }
                            if (specialWeapon.CriticalDamageOffsetArtificer != null)
                            {
                                criticalDamageOffsett = specialWeapon.CriticalDamageOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer critical damage offset: {criticalDamageOffsett}");
                            }
                            if (specialWeapon.CriticalDamageMultiplierOffsetArtificer != null)
                            {
                                criticalDamageMultiplierOffset = specialWeapon.CriticalDamageMultiplierOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer critical damage multiplier offset: {criticalDamageMultiplierOffset}");
                            }
                        }

                        if (Settings.Value.Mysticism)
                        {
                            if (specialWeapon.DamageOffsetMysticism != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetMysticism.Value;
                                _weaponHelper?.DebugLog($"Using Mysticism damage offset: {specialDamageOffset}");
                            }
                        }

                        weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + specialDamageOffset);
                        weaponOverride.Data.Speed = Math.Max(0f, settings.Speed + speedOffset);
                        weaponOverride.Data.Reach = Math.Max(0f, settings.Reach + reachOffset);
                        weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger + staggerOffset);
                        weaponOverride.Critical.Damage = (ushort)Math.Max(0, (ushort)Math.Floor(weaponOverride.BasicStats.Damage / 2.0) + criticalDamageOffsett);
                        weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageMultiplier + criticalDamageMultiplierOffset);

                        _weaponHelper?.DebugLog($"Successfully processed special weapon: {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"Final stats:");
                        _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
                        _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
                        _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
                        _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
                        _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
                        _weaponHelper?.DebugLog($"\n\n========================================\n========================================\n\n");


                        break;
                    }
                }
            }
        }

        private static void ProcessWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, WeaponSettings settings)
        {
            // Get damage offset and check if weapon is special
            var damageOffset = _weaponHelper?.GetDamageOffset(weapon, state.LinkCache, Settings.Value.WACCFMaterialTiers);
            if (damageOffset == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not determine damage offset for {weapon.EditorID}");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Calculate base and final damage
            float baseDamage = settings.Damage;
            float finalDamage = baseDamage + damageOffset.Value;

            // Apply stats from settings
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, finalDamage);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger);

            // Check for Stalhrim stagger bonus and damage bonus
            if (!Settings.Value.WACCFMaterialTiers &&
                weaponOverride.Data.Stagger > 0 &&
                weapon.Keywords?.Select(k => k.FormKey.ToString()).Contains("DLC2WeaponMaterialStalhrim") == true)
            {
                weaponOverride.Data.Stagger += 0.1f;
                _weaponHelper?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}");
            }

            // if weapon keywords contains DLC2WeaponMaterialStalhrim and either WeapTypeWarAxe or WeapTypeMace, add 1 damage
            if (weapon.Keywords?.Select(k => k.FormKey.ToString()).Contains("DLC2WeaponMaterialStalhrim") == true &&
                (weapon.Keywords?.Select(k => k.FormKey.ToString()).Contains("WeapTypeWarAxe") == true ||
                weapon.Keywords?.Select(k => k.FormKey.ToString()).Contains("WeapTypeMace") == true))
            {
                weaponOverride.BasicStats.Damage += 1;
            }

            // Calculate critical damage
            if (weaponOverride.Critical == null)
            {
                weaponOverride.Critical = new();
            }

            // Calculate expected base critical damage
            int expectedBaseCriticalDamage;
            if (settings.UseFloorDivision)
            {
                expectedBaseCriticalDamage = (int)Math.Floor(baseDamage / 2);
            }
            else
            {
                expectedBaseCriticalDamage = (int)Math.Ceiling(baseDamage / 2);
            }

            // Calculate critical damage offset
            int actualCriticalDamage = settings.CriticalDamage;
            int criticalDamageOffset = actualCriticalDamage - expectedBaseCriticalDamage;

            // Calculate final critical damage
            int finalCriticalDamage;
            if (settings.UseFloorDivision)
            {
                finalCriticalDamage = (int)Math.Floor(finalDamage / 2) + criticalDamageOffset;
            }
            else
            {
                finalCriticalDamage = (int)Math.Ceiling(finalDamage / 2) + criticalDamageOffset;
            }

            // Apply critical damage stats
            weaponOverride.Critical.Damage = (ushort)Math.Max(0, finalCriticalDamage);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageMultiplier);

            _weaponHelper?.DebugLog($"Successfully processed weapon: {weapon.EditorID}");
            _weaponHelper?.DebugLog($"Final stats:");
            _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
            _weaponHelper?.DebugLog($"\n\n========================================\n========================================\n\n");

        }
    }
}
