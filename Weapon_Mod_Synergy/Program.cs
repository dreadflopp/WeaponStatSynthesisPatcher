using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Order;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using Mutagen.Bethesda.Plugins.Binary.Headers;
#pragma warning disable CA1416 

namespace Weapon_Mod_Synergy
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;
        private static WeaponHelper? _weaponHelper;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Weapon_Mod_Synergy.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {

            // Initialize enabled weapon types from settings
            var enabledWeaponTypes = new Dictionary<string, WeaponSettings>();

            // Get all properties of type WeaponSettings from the Settings class
            var settingsProperties = typeof(Settings).GetProperties()
                .Where(p => p.PropertyType == typeof(WeaponSettings));

            foreach (var prop in settingsProperties)
            {
                var settings = prop.GetValue(Settings.Value) as WeaponSettings;
                if (settings != null)
                {
                    // Use the property name as the weapon type
                    enabledWeaponTypes.Add(prop.Name, settings);
                    _weaponHelper?.DebugLog($"Enabled weapon type: {prop.Name}");
                }
                else
                {
                    _weaponHelper?.DebugLog($"Warning: Could not get weapon settings for {prop.Name}");
                }
            }

            // Create WeaponHelper instance
            _weaponHelper = new WeaponHelper(enabledWeaponTypes, Console.WriteLine, state);

            // Get the list of plugins to include or exclude
            var pluginList = Settings.Value.PluginList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Get the list of ignored weapon form keys
            var ignoredWeaponFormKeys = Settings.Value.IgnoredWeaponFormKeys
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            _weaponHelper?.DebugLog($"Raw ignored weapons string: '{Settings.Value.IgnoredWeaponFormKeys}'");

            Console.WriteLine("Plugin Processing Settings:");
            Console.WriteLine($"Filter Mode: {Settings.Value.PluginFilter}");
            Console.WriteLine("Plugin List:");
            foreach (var plugin in pluginList)
            {
                Console.WriteLine($"     {plugin}");
            }
            Console.WriteLine();

            // Get all available plugins in load order
            var availablePlugins = state.LoadOrder.PriorityOrder
                .Select(mod => mod.ModKey.FileName.String)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Check for missing plugins if we're in include mode
            if (Settings.Value.PluginFilter == PluginFilter.IncludePlugins)
            {
                var missingPlugins = pluginList.Where(p => !availablePlugins.Contains(p)).ToList();
                if (missingPlugins.Any())
                {
                    Console.WriteLine("WARNING: The following plugins were listed for inclusion but could not be found:");
                    foreach (var plugin in missingPlugins)
                    {
                        Console.WriteLine($"     {plugin}");
                    }
                    Console.WriteLine();
                }
            }

            Console.WriteLine("Processing the following plugins:");
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (shouldProcess)
                {
                    Console.WriteLine($"     {modGetter.ModKey.FileName}");
                }
            }
            Console.WriteLine();

            // Verify form keys in special_weapons.json
            if (WeaponHelper.DebugMode)
                VerifyFormKeys(state);

            // Process weapons from plugins
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (!shouldProcess) continue;

                _weaponHelper?.DebugLog($"========================================");
                Console.WriteLine($"Processing mod: {modGetter.ModKey.FileName}");
                _weaponHelper?.DebugLog($"========================================");

                // Process each weapon from the current mod
                foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()
                    .Where(w => w.FormKey.ModKey == modGetter.ModKey))
                {
                    _weaponHelper?.DebugLog($"------------------------------------------");
                    _weaponHelper?.DebugLog($"Processing weapon: {weapon.EditorID}");
                    _weaponHelper?.DebugLog($"------------------------------------------");
                    bool isSpecialWeapon = _weaponHelper?.IsSpecialWeapon(weapon) ?? false;
                    _weaponHelper?.DebugLog($"Is EDID {weapon.EditorID} a Special Weapon: {isSpecialWeapon}");
                    bool isProcessNonPlayable = weapon.FormKey.ModKey.FileName.ToString().Equals("ccbgssse025-advdsgs.esm", StringComparison.OrdinalIgnoreCase);
                    _weaponHelper?.DebugLog($"Is EDID {weapon.EditorID} from mod with non playable weapons that should be processed: {isProcessNonPlayable}");
                    // Skip if weapon is not playable and it is not from mod ccbgssse025-advdsgs.esm
                    if (weapon.Data?.Flags.HasFlag(WeaponData.Flag.NonPlayable) == true && !isSpecialWeapon && !isProcessNonPlayable)
                    {
                        _weaponHelper?.DebugLog($"Skipping non-playable weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Skip if weapon uses a template
                    if (weapon.Template?.FormKey != null &&
                        !weapon.Template.FormKey.IsNull &&
                        weapon.Template.FormKey.ToString() != "Null" &&
                        !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Skipping template weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Check if weapon should be ignored
                    var formKeyString = weapon.FormKey.ToString();
                    if (formKeyString != null && ignoredWeaponFormKeys.Contains(formKeyString) && !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Weapon {weapon.EditorID} is in ignoredWeaponFormKeys list");
                        continue;
                    }

                    // Get weapon setting key
                    var weaponSettingKey = _weaponHelper?.GetWeaponSettingKey(weapon, state.LinkCache);
                    if (weaponSettingKey == null)
                    {
                        _weaponHelper?.DebugLog($"Warning: Could not determine weapon setting key for {weapon.EditorID}");
                        continue;
                    }

                    // Get weapon settings
                    if (!enabledWeaponTypes.TryGetValue(weaponSettingKey, out var settings))
                    {
                        _weaponHelper?.DebugLog($"{weaponSettingKey} is not enabled in settings");
                        continue;
                    }
                    _weaponHelper?.DebugLog($"Match found for weapon {weapon.EditorID} with type {weaponSettingKey}");
                    _weaponHelper?.DebugLog($"Weapon settings for {weaponSettingKey}:");
                    _weaponHelper?.DebugLog($"- Base Damage: {settings.Damage}");
                    _weaponHelper?.DebugLog($"- Reach: {settings.Reach}");
                    _weaponHelper?.DebugLog($"- Speed: {settings.Speed}");
                    _weaponHelper?.DebugLog($"- Stagger: {settings.Stagger}");
                    _weaponHelper?.DebugLog($"- Critical Damage: {settings.CriticalDamage}");
                    _weaponHelper?.DebugLog($"- Critical Damage Multiplier: {settings.CriticalDamageMultiplier}");
                    _weaponHelper?.DebugLog($"- Use Floor Division: {settings.UseFloorDivision}");

                    // Process weapon based on if it is a special weapon or not
                    if (isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Processing special weapon: {weapon.EditorID}");
                        ProcessSpecialWeapon(weapon, state, settings);
                    }
                    else
                    {
                        _weaponHelper?.DebugLog($"Processing weapon: {weapon.EditorID}");
                        ProcessWeapon(weapon, state, settings);
                    }
                }
            }
        }

        private static void ProcessSpecialWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, WeaponSettings settings)
        {
            var specialWeapons = _weaponHelper?.GetLoadedSpecialWeapons();
            if (specialWeapons == null) { _weaponHelper?.DebugLog($"ERROR: No special weapons data loaded. Skipping special weapon checks."); }
            else
            {
                foreach (var specialWeapon in specialWeapons)
                {
                    if (string.IsNullOrEmpty(specialWeapon.FormKey)) { _weaponHelper?.DebugLog($"ERROR: Special weapon {specialWeapon.EditorID} has no form key. Skipping."); continue; }

                    if (FormKey.TryFactory(specialWeapon.FormKey, out var formKey) && weapon.FormKey == formKey)
                    {
                        _weaponHelper?.DebugLog($"Found by form key: {weapon.FormKey}");

                        // Create a copy of the weapon for modification
                        var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
                        if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
                        {
                            _weaponHelper?.DebugLog($"ERROR: Could not create override for {weapon.EditorID}. Skipping.");
                            continue;
                        }

                        // Apply special weapon offsets
                        int specialDamageOffset = specialWeapon.DamageOffset ?? 0;
                        float speedOffset = specialWeapon.SpeedOffset ?? 0;
                        float reachOffset = specialWeapon.ReachOffset ?? 0;
                        float staggerOffset = specialWeapon.StaggerOffset ?? 0;
                        int criticalDamageOffsett = specialWeapon.CriticalDamageOffset ?? 0;
                        float criticalDamageMultiplierOffset = specialWeapon.CriticalDamageMultiplierOffset ?? 0;

                        _weaponHelper?.DebugLog($"Applying special weapon offsets for {weapon.EditorID}:");
                        _weaponHelper?.DebugLog($"  - Damage Offset: {specialDamageOffset}");
                        _weaponHelper?.DebugLog($"  - Speed Offset: {speedOffset}");
                        _weaponHelper?.DebugLog($"  - Reach Offset: {reachOffset}");
                        _weaponHelper?.DebugLog($"  - Stagger Offset: {staggerOffset}");
                        _weaponHelper?.DebugLog($"  - Critical Damage Offset: {criticalDamageOffsett}");
                        _weaponHelper?.DebugLog($"  - Critical Damage Multiplier Offset: {criticalDamageMultiplierOffset}");

                        if (Settings.Value.WACCFMaterialTiers)
                        {
                            if (specialWeapon.DamageOffsetWaccf != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF damage offset: {specialDamageOffset}");
                            }
                            if (specialWeapon.SpeedOffsetWaccf != null)
                            {
                                speedOffset = specialWeapon.SpeedOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF speed offset: {speedOffset}");
                            }
                            if (specialWeapon.ReachOffsetWaccf != null)
                            {
                                reachOffset = specialWeapon.ReachOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF reach offset: {reachOffset}");
                            }
                            if (specialWeapon.StaggerOffsetWaccf != null)
                            {
                                staggerOffset = specialWeapon.StaggerOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF stagger offset: {staggerOffset}");
                            }
                            if (specialWeapon.CriticalDamageOffsetWaccf != null)
                            {
                                criticalDamageOffsett = specialWeapon.CriticalDamageOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF critical damage offset: {criticalDamageOffsett}");
                            }
                            if (specialWeapon.CriticalDamageMultiplierOffsetWaccf != null)
                            {
                                criticalDamageMultiplierOffset = specialWeapon.CriticalDamageMultiplierOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF critical damage multiplier offset: {criticalDamageMultiplierOffset}");
                            }
                        }

                        if (Settings.Value.Artificer)
                        {
                            if (specialWeapon.DamageOffsetArtificer != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer damage offset: {specialDamageOffset}");
                            }
                            if (specialWeapon.SpeedOffsetArtificer != null)
                            {
                                speedOffset = specialWeapon.SpeedOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer speed offset: {speedOffset}");
                            }
                            if (specialWeapon.ReachOffsetArtificer != null)
                            {
                                reachOffset = specialWeapon.ReachOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer reach offset: {reachOffset}");
                            }
                            if (specialWeapon.StaggerOffsetArtificer != null)
                            {
                                staggerOffset = specialWeapon.StaggerOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer stagger offset: {staggerOffset}");
                            }
                            if (specialWeapon.CriticalDamageOffsetArtificer != null)
                            {
                                criticalDamageOffsett = specialWeapon.CriticalDamageOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer critical damage offset: {criticalDamageOffsett}");
                            }
                            if (specialWeapon.CriticalDamageMultiplierOffsetArtificer != null)
                            {
                                criticalDamageMultiplierOffset = specialWeapon.CriticalDamageMultiplierOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer critical damage multiplier offset: {criticalDamageMultiplierOffset}");
                            }
                        }

                        if (Settings.Value.Mysticism)
                        {
                            if (specialWeapon.DamageOffsetMysticism != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetMysticism.Value;
                                _weaponHelper?.DebugLog($"Using Mysticism damage offset: {specialDamageOffset}");
                            }
                        }

                        weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + specialDamageOffset);
                        weaponOverride.Data.Speed = Math.Max(0f, settings.Speed + speedOffset);
                        weaponOverride.Data.Reach = Math.Max(0f, settings.Reach + reachOffset);
                        weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger + staggerOffset);
                        weaponOverride.Critical.Damage = (ushort)Math.Max(0, (ushort)Math.Floor(weaponOverride.BasicStats.Damage / 2.0) + criticalDamageOffsett);
                        weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageMultiplier + criticalDamageMultiplierOffset);

                        _weaponHelper?.DebugLog($"Successfully processed special weapon: {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"Final stats:");
                        _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
                        _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
                        _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
                        _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
                        _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");

                        break;
                    }
                }
            }
        }

        private static void ProcessWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, WeaponSettings settings)
        {
            // Get damage offset and check if weapon is special
            var damageOffset = _weaponHelper?.GetDamageOffset(weapon, state.LinkCache, Settings.Value.WACCFMaterialTiers);
            if (damageOffset == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not determine damage offset for {weapon.EditorID}. Skipping.");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Calculate base and final damage
            float baseDamage = settings.Damage;
            float finalDamage = baseDamage + damageOffset.Value;

            // Apply stats from settings
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, finalDamage);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger);

            // Check for Stalhrim weapons and apply stagger bonus if WACCF material tiers are disabled
            if (!Settings.Value.WACCFMaterialTiers && weaponOverride.Data.Stagger > 0)
            {
                bool isStalhrim = weapon.Keywords?.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false) ?? false;
                _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Stagger: {weaponOverride.Data.Stagger}");
                if (isStalhrim)
                {
                    weaponOverride.Data.Stagger += 0.1f;
                    _weaponHelper?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}. Stagger: {weaponOverride.Data.Stagger}");
                }
            }

            // Check for Stalhrim weapons that are either war axes or maces and add damage bonus
            if (weapon.Keywords != null)
            {
                bool isStalhrim = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false);
                bool isWarAxe = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeWarAxe") ?? false);
                bool isMace = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeMace") ?? false);

                if (isStalhrim && (isWarAxe || isMace))
                {
                    _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Is War Axe: {isWarAxe}. Is Mace: {isMace}. Damage: {weaponOverride.BasicStats.Damage}");
                    weaponOverride.BasicStats.Damage += 1;
                    _weaponHelper?.DebugLog($"Applied Stalhrim damage bonus to {weapon.EditorID}. Damage: {weaponOverride.BasicStats.Damage}");
                }
            }

            // Calculate critical damage
            if (weaponOverride.Critical == null)
            {
                weaponOverride.Critical = new();
            }

            // Calculate expected base critical damage
            int expectedBaseCriticalDamage;
            if (settings.UseFloorDivision)
            {
                expectedBaseCriticalDamage = (int)Math.Floor(baseDamage / 2);
            }
            else
            {
                expectedBaseCriticalDamage = (int)Math.Ceiling(baseDamage / 2);
            }

            // Calculate critical damage offset
            int actualCriticalDamage = settings.CriticalDamage;
            int criticalDamageOffset = actualCriticalDamage - expectedBaseCriticalDamage;

            // Calculate final critical damage
            int finalCriticalDamage;
            if (settings.UseFloorDivision)
            {
                finalCriticalDamage = (int)Math.Floor(finalDamage / 2) + criticalDamageOffset;
            }
            else
            {
                finalCriticalDamage = (int)Math.Ceiling(finalDamage / 2) + criticalDamageOffset;
            }

            // Apply critical damage stats
            weaponOverride.Critical.Damage = (ushort)Math.Max(0, finalCriticalDamage);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageMultiplier);

            _weaponHelper?.DebugLog($"Successfully processed weapon: {weapon.EditorID}");
            _weaponHelper?.DebugLog($"Final stats:");
            _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
        }

        /// <summary>
        /// Verifies that all form keys in the special_weapons.json file are correct by looking up each editor ID.
        /// </summary>
        private static void VerifyFormKeys(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Verifying form keys in special_weapons.json...");

            // Get the path to the special_weapons.json file
            string patcherDirectory = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) ?? "";
            string specialWeaponsPath = Path.Combine(patcherDirectory, "special_weapons.json");

            if (!File.Exists(specialWeaponsPath))
            {
                Console.WriteLine($"Error: special_weapons.json not found at {specialWeaponsPath}");
                return;
            }

            // Load the special weapons data
            var specialWeaponsJson = File.ReadAllText(specialWeaponsPath);
            var specialWeapons = System.Text.Json.JsonSerializer.Deserialize<List<SpecialWeaponData>>(specialWeaponsJson) ?? new List<SpecialWeaponData>();

            Console.WriteLine($"Loaded {specialWeapons.Count} special weapons from JSON file.");

            // Lists to store valid and invalid entries
            var validEntries = new List<(string EditorID, string FormKey)>();
            var invalidEntries = new List<(string EditorID, string FormKey, string Error)>();
            var suggestedFormKeys = new List<(string EditorID, string CurrentFormKey, string SuggestedFormKey)>();

            // Check each special weapon
            foreach (var specialWeapon in specialWeapons)
            {
                if (string.IsNullOrEmpty(specialWeapon.EditorID))
                {
                    invalidEntries.Add((specialWeapon.EditorID ?? "null", specialWeapon.FormKey ?? "null", "EditorID is null or empty"));
                    continue;
                }

                if (string.IsNullOrEmpty(specialWeapon.FormKey))
                {
                    invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey ?? "null", "FormKey is null or empty"));
                    continue;
                }

                // Try to parse the form key
                if (!FormKey.TryFactory(specialWeapon.FormKey, out var formKey))
                {
                    invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Invalid form key format"));
                    continue;
                }

                try
                {
                    // Look up the weapon by form key
                    var weapon = state.LinkCache.Resolve<IWeaponGetter>(formKey);

                    if (weapon == null)
                    {
                        // Try to look up the weapon by editor ID, looking at earliest version in load order
                        var weaponsByEditorID = state.LoadOrder.PriorityOrder.Weapon()
                            .WinningOverrides()
                            .Where(w => w.EditorID == specialWeapon.EditorID)
                            .OrderBy(w => w.FormKey.ModKey.ToString())  // Order by mod name to get earliest version
                            .ToList();

                        if (weaponsByEditorID.Any())
                        {
                            // Found the weapon by editor ID, but with a different form key
                            var foundWeapon = weaponsByEditorID.First();
                            var suggestedFormKey = $"{foundWeapon.FormKey.ID:X6}:{foundWeapon.FormKey.ModKey.FileName}";
                            suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                        }
                        else
                        {
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                        }
                        continue;
                    }

                    // Check if the editor ID matches
                    if (weapon.EditorID != specialWeapon.EditorID)
                    {
                        // Get all versions of this weapon from all mods
                        var allVersions = new List<IWeaponGetter>();

                        // Get all mods that contain this form
                        foreach (var mod in state.LoadOrder.ListedOrder)
                        {
                            // Try to get the weapon from this specific mod
                            if (mod.Mod?.Weapons.TryGetValue(weapon.FormKey, out var weaponInMod) == true)
                            {
                                allVersions.Add(weaponInMod);
                            }
                        }

                        // Sort by load order to get earliest version
                        allVersions = allVersions
                            .OrderBy(w => state.LoadOrder.ListedOrder.ToList().IndexOf(state.LoadOrder.ListedOrder.First(m => m.ModKey == w.FormKey.ModKey)))
                            .ToList();

                        if (allVersions.Any())
                        {
                            var earliestVersion = allVersions.First();
                            if (earliestVersion.EditorID == specialWeapon.EditorID)
                            {
                                // The earliest version matches our editor ID, so this is valid
                                validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                            }
                            else
                            {
                                var earliestMod = earliestVersion.FormKey.ModKey.ToString();
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey,
                                    $"EditorID mismatch: expected '{specialWeapon.EditorID}', found '{weapon.EditorID}' in current version. " +
                                    $"Earliest version in mod '{earliestMod}' has EditorID '{earliestVersion.EditorID}'"));
                            }
                        }
                        else
                        {
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey,
                                $"EditorID mismatch: expected '{specialWeapon.EditorID}', found '{weapon.EditorID}'"));
                        }
                        continue;
                    }

                    // If we get here, the form key is valid
                    validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                }
                catch (Mutagen.Bethesda.Plugins.Exceptions.MissingRecordException)
                {
                    // Try to look up the weapon by editor ID, looking at earliest version in load order
                    var weaponsByEditorID = state.LoadOrder.PriorityOrder.Weapon()
                        .WinningOverrides()
                        .Where(w => w.EditorID == specialWeapon.EditorID)
                        .OrderBy(w => w.FormKey.ModKey.ToString())  // Order by mod name to get earliest version
                        .ToList();

                    if (weaponsByEditorID.Any())
                    {
                        // Found the weapon by editor ID, but with a different form key
                        var foundWeapon = weaponsByEditorID.First();
                        var suggestedFormKey = $"{foundWeapon.FormKey.ID:X6}:{foundWeapon.FormKey.ModKey.FileName}";
                        suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                    }
                    else
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                    }
                }
            }

            // Print results
            Console.WriteLine("\n=== VALID FORM KEYS ===");
            if (validEntries.Count == 0)
            {
                Console.WriteLine("No valid form keys found.");
            }
            else
            {
                foreach (var entry in validEntries)
                {
                    Console.WriteLine($"✓ {entry.EditorID}: {entry.FormKey}");
                }
            }

            Console.WriteLine("\n=== INVALID FORM KEYS ===");
            if (invalidEntries.Count == 0)
            {
                Console.WriteLine("No invalid form keys found.");
            }
            else
            {
                foreach (var entry in invalidEntries)
                {
                    Console.WriteLine($"✗ {entry.EditorID}: {entry.FormKey} - {entry.Error}");
                }
            }

            Console.WriteLine($"\nSummary: {validEntries.Count} valid, {invalidEntries.Count} invalid form keys.");

            // Print suggested form keys
            if (suggestedFormKeys.Count > 0)
            {
                Console.WriteLine("\n=== SUGGESTED FORM KEY CORRECTIONS ===");
                Console.WriteLine("The following entries have incorrect form keys. Here are the suggested corrections:");
                foreach (var suggestion in suggestedFormKeys)
                {
                    Console.WriteLine($"  {suggestion.EditorID}: {suggestion.CurrentFormKey} -> {suggestion.SuggestedFormKey}");
                }
            }
        }
    }
}
