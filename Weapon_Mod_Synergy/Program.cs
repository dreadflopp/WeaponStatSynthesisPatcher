using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Order;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using Mutagen.Bethesda.Plugins.Binary.Headers;
#pragma warning disable CA1416 

namespace Weapon_Mod_Synergy
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;
        private static WeaponHelper? _weaponHelper;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Weapon_Mod_Synergy.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            // Create WeaponHelper instance with the new Settings structure
            _weaponHelper = new WeaponHelper(Settings.Value, Console.WriteLine, state);

            // Get the list of plugins to include or exclude
            var pluginList = Settings.Value.PluginList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Get the list of ignored weapon form keys
            var ignoredWeaponFormKeys = Settings.Value.IgnoredWeaponFormKeys
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            _weaponHelper?.DebugLog($"Raw ignored weapons string: '{Settings.Value.IgnoredWeaponFormKeys}'");

            Console.WriteLine("Plugin Processing Settings:");
            Console.WriteLine($"Filter Mode: {Settings.Value.PluginFilter}");
            Console.WriteLine("Plugin List:");
            foreach (var plugin in pluginList)
            {
                Console.WriteLine($"     {plugin}");
            }
            Console.WriteLine();

            // Get all available plugins in load order
            var availablePlugins = state.LoadOrder.PriorityOrder
                .Select(mod => mod.ModKey.FileName.String)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Check for missing plugins if we're in include mode
            if (Settings.Value.PluginFilter == PluginFilter.IncludePlugins)
            {
                var missingPlugins = pluginList.Where(p => !availablePlugins.Contains(p)).ToList();
                if (missingPlugins.Any())
                {
                    Console.WriteLine("WARNING: The following plugins were listed for inclusion but could not be found:");
                    foreach (var plugin in missingPlugins)
                    {
                        Console.WriteLine($"     {plugin}");
                    }
                    Console.WriteLine();
                }
            }

            Console.WriteLine("Processing the following plugins:");
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (shouldProcess)
                {
                    Console.WriteLine($"     {modGetter.ModKey.FileName}");
                }
            }
            Console.WriteLine();

            // Verify form keys in special_weapons.json
            VerifyFormKeys(state);

            // Process weapons from plugins
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (!shouldProcess) continue;

                _weaponHelper?.DebugLog($"========================================");
                Console.WriteLine($"Processing mod: {modGetter.ModKey.FileName}");
                _weaponHelper?.DebugLog($"========================================");

                // Process each weapon from the current mod
                foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()
                    .Where(w => w.FormKey.ModKey == modGetter.ModKey))
                {
                    _weaponHelper?.DebugLog($"------------------------------------------");
                    _weaponHelper?.DebugLog($"Processing weapon: {weapon.EditorID}");
                    _weaponHelper?.DebugLog($"------------------------------------------");
                    bool isSpecialWeapon = _weaponHelper?.IsSpecialWeapon(weapon) ?? false;
                    _weaponHelper?.DebugLog($"Is EDID {weapon.EditorID} a Special Weapon: {isSpecialWeapon}");
                    bool isProcessNonPlayable = weapon.FormKey.ModKey.FileName.ToString().Equals("ccbgssse025-advdsgs.esm", StringComparison.OrdinalIgnoreCase);
                    _weaponHelper?.DebugLog($"Is EDID {weapon.EditorID} from mod with non playable weapons that should be processed: {isProcessNonPlayable}");
                    // Skip if weapon is not playable and it is not from mod ccbgssse025-advdsgs.esm
                    if (weapon.Data?.Flags.HasFlag(WeaponData.Flag.NonPlayable) == true && !isSpecialWeapon && !isProcessNonPlayable)
                    {
                        _weaponHelper?.DebugLog($"Skipping non-playable weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Skip if weapon uses a template
                    if (weapon.Template?.FormKey != null &&
                        !weapon.Template.FormKey.IsNull &&
                        weapon.Template.FormKey.ToString() != "Null" &&
                        !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Skipping template weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Check if weapon should be ignored
                    var formKeyString = weapon.FormKey.ToString();
                    if (formKeyString != null && ignoredWeaponFormKeys.Contains(formKeyString) && !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Weapon {weapon.EditorID} is in ignoredWeaponFormKeys list");
                        continue;
                    }

                    // Get weapon setting key
                    var weaponSettingKey = _weaponHelper?.GetWeaponSettingKey(weapon, state.LinkCache);
                    if (weaponSettingKey == null)
                    {
                        _weaponHelper?.DebugLog($"Warning: Could not determine weapon setting key for {weapon.EditorID}");
                        continue;
                    }

                    // Process weapon based on if it is a special weapon or not
                    if (isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Processing special weapon: {weapon.EditorID}");
                        ProcessSpecialWeapon(weapon, state, weaponSettingKey);
                    }
                    else
                    {
                        _weaponHelper?.DebugLog($"Processing weapon: {weapon.EditorID}");
                        ProcessWeapon(weapon, state, weaponSettingKey);
                    }
                }
            }
        }

        private static void ProcessSpecialWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, string weaponSettingKey)
        {
            if (weapon == null || state == null || string.IsNullOrEmpty(weaponSettingKey))
            {
                _weaponHelper?.DebugLog("Invalid parameters in ProcessSpecialWeapon");
                return;
            }

            // Get weapon settings from the appropriate category
            WeaponSettings? settings = null;
            var categories = new[]
            {
                Settings.Value.Daggers,
                Settings.Value.OnehandedSwords,
                Settings.Value.OnehandedSpears,
                Settings.Value.OnehandedBluntWeapons,
                Settings.Value.OnehandedAxes,
                Settings.Value.TwohandedSwords,
                Settings.Value.TwohandedSpears,
                Settings.Value.TwohandedBluntWeapons,
                Settings.Value.TwohandedAxes,
                Settings.Value.Others
            };

            foreach (var category in categories)
            {
                if (category.Weapons.TryGetValue(weaponSettingKey, out var weaponSettings))
                {
                    settings = weaponSettings;
                    break;
                }
            }

            if (settings == null)
            {
                _weaponHelper?.DebugLog($"{weaponSettingKey} is not enabled in settings");
                return;
            }

            // Get special weapon data
            var specialWeapons = _weaponHelper?.GetLoadedSpecialWeapons();
            var specialWeaponsWaccf = _weaponHelper?.GetLoadedSpecialWeaponsWaccf();
            var specialWeaponsMysticism = _weaponHelper?.GetLoadedSpecialWeaponsMysticism();
            var specialWeaponsArtificer = _weaponHelper?.GetLoadedSpecialWeaponsArtificer();

            if (specialWeapons == null)
            {
                _weaponHelper?.DebugLog($"ERROR: No special weapons data loaded. Skipping special weapon checks.");
                return;
            }
            if (specialWeaponsWaccf == null)
            {
                _weaponHelper?.DebugLog($"Warning: No special weapons WACCF data loaded.");
            }
            if (specialWeaponsMysticism == null)
            {
                _weaponHelper?.DebugLog($"Warning: No special weapons mysticism data loaded.");
            }
            if (specialWeaponsArtificer == null)
            {
                _weaponHelper?.DebugLog($"Warning: No special weapons artificer data loaded.");
            }


            // Find matching special weapon
            SpecialWeaponData? specialWeapon = null;
            foreach (var sw in specialWeapons)
            {
                if (string.IsNullOrEmpty(sw.FormKey))
                {
                    _weaponHelper?.DebugLog($"ERROR: Special weapon {sw.EditorID} has no form key. Skipping.");
                    continue;
                }

                if (FormKey.TryFactory(sw.FormKey, out var formKey) && weapon.FormKey == formKey)
                {
                    _weaponHelper?.DebugLog($"Found by form key: {weapon.FormKey}");
                    specialWeapon = sw;
                    break;
                }
            }

            if (specialWeapon == null)
            {
                _weaponHelper?.DebugLog($"No special weapon data found for {weapon.EditorID}");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Apply special weapon offsets
            int damageOffset = specialWeapon.DamageOffset ?? 0;
            float speedOffset = specialWeapon.SpeedOffset ?? 0;
            float reachOffset = specialWeapon.ReachOffset ?? 0;
            float staggerOffset = specialWeapon.StaggerOffset ?? 0;
            int criticalDamageOffset = specialWeapon.CriticalDamageOffset ?? 0;
            float criticalDamageChanceMultiplierOffset = specialWeapon.CriticalDamageChanceMultiplierOffset ?? 0;

            _weaponHelper?.DebugLog($"Read basic special weapon offsets for {weapon.EditorID}:");
            _weaponHelper?.DebugLog($"  - Damage Offset: {damageOffset}");
            _weaponHelper?.DebugLog($"  - Speed Offset: {speedOffset}");
            _weaponHelper?.DebugLog($"  - Reach Offset: {reachOffset}");
            _weaponHelper?.DebugLog($"  - Stagger Offset: {staggerOffset}");
            _weaponHelper?.DebugLog($"  - Critical Damage Offset: {criticalDamageOffset}");
            _weaponHelper?.DebugLog($"  - Critical Damage Chance Multiplier Offset: {criticalDamageChanceMultiplierOffset}");

            if (Settings.Value.WACCFMaterialTiers)
            {
                if (specialWeaponsWaccf == null)
                {
                    _weaponHelper?.DebugLog($"Warning: No special weapons WACCF data loaded.");
                }
                else if (specialWeaponsWaccf.Any(sw => sw.FormKey == specialWeapon.FormKey))
                {
                    var waccfWeapon = specialWeaponsWaccf.FirstOrDefault(sw => sw.FormKey == specialWeapon.FormKey);
                    if (waccfWeapon != null)
                    {
                        if (waccfWeapon.DamageOffset != null)
                        {
                            damageOffset = waccfWeapon.DamageOffset.Value;
                            _weaponHelper?.DebugLog($"Using WACCF damage offset: {damageOffset}");
                        }
                        if (waccfWeapon.SpeedOffset != null)
                        {
                            speedOffset = waccfWeapon.SpeedOffset.Value;
                            _weaponHelper?.DebugLog($"Using WACCF speed offset: {speedOffset}");
                        }
                        if (waccfWeapon.ReachOffset != null)
                        {
                            reachOffset = waccfWeapon.ReachOffset.Value;
                            _weaponHelper?.DebugLog($"Using WACCF reach offset: {reachOffset}");
                        }
                        if (waccfWeapon.StaggerOffset != null)
                        {
                            staggerOffset = waccfWeapon.StaggerOffset.Value;
                            _weaponHelper?.DebugLog($"Using WACCF stagger offset: {staggerOffset}");
                        }
                        if (waccfWeapon.CriticalDamageOffset != null)
                        {
                            criticalDamageOffset = waccfWeapon.CriticalDamageOffset.Value;
                            _weaponHelper?.DebugLog($"Using WACCF critical damage offset: {criticalDamageOffset}");
                        }
                        if (waccfWeapon.CriticalDamageChanceMultiplierOffset != null)
                        {
                            criticalDamageChanceMultiplierOffset = waccfWeapon.CriticalDamageChanceMultiplierOffset.Value;
                            _weaponHelper?.DebugLog($"Using WACCF critical damage chance multiplier offset: {criticalDamageChanceMultiplierOffset}");
                        }
                    }
                }
            }

            // id special weapon mod setting SpecialWeaponsMod equals SpecialWeaponsMod.Mysticism, check if form key is in specialWeaponsMysticism and apply the offsets from it
            if (Settings.Value.SpecialWeaponsMod == SpecialWeaponsMod.Mysticism || Settings.Value.SpecialWeaponsMod == SpecialWeaponsMod.Artificer)
            {
                if (specialWeaponsMysticism == null)
                {
                    _weaponHelper?.DebugLog($"Warning: No special weapons mysticism data loaded.");
                }
                else if (specialWeaponsMysticism.Any(sw => sw.FormKey == specialWeapon.FormKey))
                {
                    var mysticismWeapon = specialWeaponsMysticism.FirstOrDefault(sw => sw.FormKey == specialWeapon.FormKey);
                    if (mysticismWeapon != null)
                    {
                        if (mysticismWeapon.DamageOffset != null)
                        {
                            damageOffset = mysticismWeapon.DamageOffset.Value;
                            _weaponHelper?.DebugLog($"Using Mysticism damage offset: {damageOffset}");
                        }
                        if (mysticismWeapon.SpeedOffset != null)
                        {
                            speedOffset = mysticismWeapon.SpeedOffset.Value;
                            _weaponHelper?.DebugLog($"Using Mysticism speed offset: {speedOffset}");
                        }
                        if (mysticismWeapon.ReachOffset != null)
                        {
                            reachOffset = mysticismWeapon.ReachOffset.Value;
                            _weaponHelper?.DebugLog($"Using Mysticism reach offset: {reachOffset}");
                        }
                        if (mysticismWeapon.StaggerOffset != null)
                        {
                            staggerOffset = mysticismWeapon.StaggerOffset.Value;
                            _weaponHelper?.DebugLog($"Using Mysticism stagger offset: {staggerOffset}");
                        }
                        if (mysticismWeapon.CriticalDamageOffset != null)
                        {
                            criticalDamageOffset = mysticismWeapon.CriticalDamageOffset.Value;
                            _weaponHelper?.DebugLog($"Using Mysticism critical damage offset: {criticalDamageOffset}");
                        }
                        if (mysticismWeapon.CriticalDamageChanceMultiplierOffset != null)
                        {
                            criticalDamageChanceMultiplierOffset = mysticismWeapon.CriticalDamageChanceMultiplierOffset.Value;
                            _weaponHelper?.DebugLog($"Using Mysticism critical damage chance multiplier offset: {criticalDamageChanceMultiplierOffset}");
                        }
                    }
                }

            }

            if (Settings.Value.SpecialWeaponsMod == SpecialWeaponsMod.Artificer)
            {
                if (specialWeaponsArtificer == null)
                {
                    _weaponHelper?.DebugLog($"Warning: No special weapons artificer data loaded.");
                }
                else if (specialWeaponsArtificer.Any(sw => sw.FormKey == specialWeapon.FormKey))
                {
                    var artificerWeapon = specialWeaponsArtificer.FirstOrDefault(sw => sw.FormKey == specialWeapon.FormKey);
                    if (artificerWeapon != null)
                    {
                        if (artificerWeapon.DamageOffset != null)
                        {
                            damageOffset = artificerWeapon.DamageOffset.Value;
                            _weaponHelper?.DebugLog($"Using Artificer damage offset: {damageOffset}");
                        }
                        if (artificerWeapon.SpeedOffset != null)
                        {
                            speedOffset = artificerWeapon.SpeedOffset.Value;
                            _weaponHelper?.DebugLog($"Using Artificer speed offset: {speedOffset}");
                        }
                        if (artificerWeapon.ReachOffset != null)
                        {
                            reachOffset = artificerWeapon.ReachOffset.Value;
                            _weaponHelper?.DebugLog($"Using Artificer reach offset: {reachOffset}");
                        }
                        if (artificerWeapon.StaggerOffset != null)
                        {
                            staggerOffset = artificerWeapon.StaggerOffset.Value;
                            _weaponHelper?.DebugLog($"Using Artificer stagger offset: {staggerOffset}");
                        }
                        if (artificerWeapon.CriticalDamageOffset != null)
                        {
                            criticalDamageOffset = artificerWeapon.CriticalDamageOffset.Value;
                            _weaponHelper?.DebugLog($"Using Artificer critical damage offset: {criticalDamageOffset}");
                        }
                        if (artificerWeapon.CriticalDamageChanceMultiplierOffset != null)
                        {
                            criticalDamageChanceMultiplierOffset = artificerWeapon.CriticalDamageChanceMultiplierOffset.Value;
                            _weaponHelper?.DebugLog($"Using Artificer critical damage chance multiplier offset: {criticalDamageChanceMultiplierOffset}");
                        }
                    }
                }
            }

            // Apply stats with special weapon offsets
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + damageOffset);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed + speedOffset);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach + reachOffset);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger + staggerOffset);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageChanceMultiplier + criticalDamageChanceMultiplierOffset);

            // Apply critical damage stats with special weapon offset
            ushort criticalDamage = (ushort)Math.Floor(settings.CriticalDamageMultiplier * (settings.CriticalDamageOffset + criticalDamageOffset + (float)weaponOverride.BasicStats.Damage / 2));
            weaponOverride.Critical.Damage = Math.Max((ushort)0, criticalDamage);

            _weaponHelper?.DebugLog($"Successfully processed special weapon: {weapon.EditorID}");
            _weaponHelper?.DebugLog($"Final stats:");
            _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
            _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponHelper?.DebugLog($"- Critical Damage Chance Multiplier: {weaponOverride.Critical.PercentMult}");
        }

        private static void ProcessWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, string weaponSettingKey)
        {
            if (weapon == null || state == null || string.IsNullOrEmpty(weaponSettingKey))
            {
                _weaponHelper?.DebugLog("Invalid parameters in ProcessWeapon");
                return;
            }

            // Get weapon settings from the appropriate category
            WeaponSettings? settings = null;
            var categories = new[]
            {
                Settings.Value.Daggers,
                Settings.Value.OnehandedSwords,
                Settings.Value.OnehandedSpears,
                Settings.Value.OnehandedBluntWeapons,
                Settings.Value.OnehandedAxes,
                Settings.Value.TwohandedSwords,
                Settings.Value.TwohandedSpears,
                Settings.Value.TwohandedBluntWeapons,
                Settings.Value.TwohandedAxes,
                Settings.Value.Others
            };

            foreach (var category in categories)
            {
                if (category.Weapons.TryGetValue(weaponSettingKey, out var weaponSettings))
                {
                    settings = weaponSettings;
                    break;
                }
            }

            if (settings == null)
            {
                _weaponHelper?.DebugLog($"{weaponSettingKey} is not enabled in settings");
                return;
            }

            // Get damage offset and check if weapon is special
            int? damageOffset = _weaponHelper?.GetDamageOffset(weapon, state.LinkCache, Settings.Value.WACCFMaterialTiers);
            if (damageOffset == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not determine damage offset for {weapon.EditorID}. Skipping.");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Apply stats
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + damageOffset.Value);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageChanceMultiplier);

            // Check for Stalhrim weapons and apply stagger bonus if WACCF material tiers are disabled
            if (!Settings.Value.WACCFMaterialTiers && weaponOverride.Data.Stagger > 0)
            {
                bool isStalhrim = weapon.Keywords?.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false) ?? false;
                _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Stagger: {weaponOverride.Data.Stagger}");
                if (isStalhrim)
                {
                    weaponOverride.Data.Stagger += 0.1f;
                    _weaponHelper?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}. Stagger: {weaponOverride.Data.Stagger}");
                }
            }

            // Check for Stalhrim weapons and apply stagger bonus if WACCF material tiers are disabled
            if (weaponOverride.Data.Stagger > 0)
            {
                bool isStalhrim = weapon.Keywords?.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false) ?? false;
                _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Stagger: {weaponOverride.Data.Stagger}");
                if (isStalhrim)
                {
                    weaponOverride.Data.Stagger += Settings.Value.StalhrimStaggerBonus;
                    _weaponHelper?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}. Stagger: {weaponOverride.Data.Stagger}");
                }
            }

            // Check for Stalhrim weapons that are either war axes or maces and add damage bonus
            if (weapon.Keywords != null)
            {
                bool isStalhrim = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false);
                bool isWarAxe = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeWarAxe") ?? false);
                bool isMace = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeMace") ?? false);

                if (isStalhrim && (isWarAxe || isMace))
                {
                    _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Is War Axe: {isWarAxe}. Is Mace: {isMace}. Damage: {weaponOverride.BasicStats.Damage}");
                    weaponOverride.BasicStats.Damage += (ushort)Settings.Value.StalhrimDamageBonus;
                    _weaponHelper?.DebugLog($"Applied Stalhrim damage bonus to {weapon.EditorID}. Damage: {weaponOverride.BasicStats.Damage}");
                }
            }

            ushort criticalDamage = (ushort)Math.Floor(settings.CriticalDamageMultiplier * (settings.CriticalDamageOffset + (float)weaponOverride.BasicStats.Damage / 2));
            // Apply critical damage stats
            weaponOverride.Critical.Damage = Math.Max((ushort)0, criticalDamage);

            _weaponHelper?.DebugLog($"Successfully processed weapon: {weapon.EditorID}");
            _weaponHelper?.DebugLog($"Final stats:");
            _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
            _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponHelper?.DebugLog($"- Critical Damage Chance Multiplier: {weaponOverride.Critical.PercentMult}");
        }

        /// <summary>
        /// Verifies that all form keys in the special_weapons.json file are correct by looking up each editor ID.
        /// </summary>
        private static void VerifyFormKeys(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Verifying form keys in special_weapons.json...");

            try
            {
                var specialWeaponsPath = state.RetrieveInternalFile("special_weapons.json");
                string jsonContent = File.ReadAllText(specialWeaponsPath);
                var specialWeapons = System.Text.Json.JsonSerializer.Deserialize<List<SpecialWeaponData>>(jsonContent) ?? new List<SpecialWeaponData>();

                _weaponHelper?.DebugLog($"Loaded {specialWeapons.Count} special weapons from JSON file.");

                // Lists to store valid and invalid entries
                var validEntries = new List<(string EditorID, string FormKey)>();
                var invalidEntries = new List<(string EditorID, string FormKey, string Error)>();
                var suggestedFormKeys = new List<(string EditorID, string CurrentFormKey, string SuggestedFormKey)>();

                // Check each special weapon
                foreach (var specialWeapon in specialWeapons)
                {
                    if (string.IsNullOrEmpty(specialWeapon.EditorID))
                    {
                        invalidEntries.Add((specialWeapon.EditorID ?? "null", specialWeapon.FormKey ?? "null", "EditorID is null or empty"));
                        continue;
                    }

                    if (string.IsNullOrEmpty(specialWeapon.FormKey))
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey ?? "null", "FormKey is null or empty"));
                        continue;
                    }

                    // Try to parse the form key
                    if (!FormKey.TryFactory(specialWeapon.FormKey, out var formKey))
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Invalid form key format"));
                        continue;
                    }

                    try
                    {
                        // Look up the weapon by form key
                        var weapon = state.LinkCache.Resolve<IWeaponGetter>(formKey);

                        if (weapon == null)
                        {
                            // Try to look up the weapon by editor ID in original definitions
                            var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                                .WinningOverrides()
                                .FirstOrDefault(w => w.EditorID == specialWeapon.EditorID);

                            if (originalWeapon != null)
                            {
                                var suggestedFormKey = $"{originalWeapon.FormKey.ID:X6}:{originalWeapon.FormKey.ModKey.FileName}";
                                suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                            }
                            else
                            {
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                            }
                            continue;
                        }

                        // Check if the editor ID matches
                        if (weapon.EditorID != specialWeapon.EditorID)
                        {
                            // Get the original definition of this weapon
                            var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                                .WinningOverrides()
                                .FirstOrDefault(w => w.FormKey == weapon.FormKey);

                            if (originalWeapon != null && originalWeapon.EditorID == specialWeapon.EditorID)
                            {
                                // The original version matches our editor ID, so this is valid
                                validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                            }
                            else
                            {
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey,
                                    $"EditorID mismatch: expected '{specialWeapon.EditorID}', found '{weapon.EditorID}' in current version. " +
                                    $"Original version has EditorID '{originalWeapon?.EditorID ?? "unknown"}'"));
                            }
                            continue;
                        }

                        // If we get here, the form key is valid
                        validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                    }
                    catch (Mutagen.Bethesda.Plugins.Exceptions.MissingRecordException)
                    {
                        // Try to look up the weapon by editor ID in original definitions
                        var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                            .WinningOverrides()
                            .FirstOrDefault(w => w.EditorID == specialWeapon.EditorID);

                        if (originalWeapon != null)
                        {
                            var suggestedFormKey = $"{originalWeapon.FormKey.ID:X6}:{originalWeapon.FormKey.ModKey.FileName}";
                            suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                        }
                        else
                        {
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                        }
                    }
                }

                // Print results
                _weaponHelper?.DebugLog("=== VALID FORM KEYS ===");
                if (validEntries.Count == 0)
                {
                    _weaponHelper?.DebugLog("No valid form keys found.");
                }
                else
                {
                    foreach (var entry in validEntries)
                    {
                        _weaponHelper?.DebugLog($"Valid: {entry.EditorID}: {entry.FormKey}");
                    }
                }

                Console.WriteLine("=== INVALID FORM KEYS ===");
                if (invalidEntries.Count == 0)
                {
                    Console.WriteLine("No invalid form keys found.");
                }
                else
                {
                    foreach (var entry in invalidEntries)
                    {
                        Console.WriteLine($"Invalid: {entry.EditorID}: {entry.FormKey} - {entry.Error}");
                    }
                }

                Console.WriteLine($"\nSummary: {validEntries.Count} valid, {invalidEntries.Count} invalid form keys.");

                // Print suggested form keys
                if (suggestedFormKeys.Count > 0)
                {
                    Console.WriteLine("\n=== SUGGESTED FORM KEY CORRECTIONS ===");
                    Console.WriteLine("The following entries have incorrect form keys. Here are the suggested corrections:");
                    foreach (var suggestion in suggestedFormKeys)
                    {
                        Console.WriteLine($"  {suggestion.EditorID}: {suggestion.CurrentFormKey} -> {suggestion.SuggestedFormKey}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error verifying form keys: {ex.Message}");
            }
        }
    }
}
