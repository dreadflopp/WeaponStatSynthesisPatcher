using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Order;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using Mutagen.Bethesda.Plugins.Binary.Headers;
#pragma warning disable CA1416 

namespace Weapon_Mod_Synergy
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;
        private static WeaponDataManager? _weaponDataManager;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Weapon_Mod_Synergy.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            // Create WeaponDataManager instance with the new Settings structure
            _weaponDataManager = new WeaponDataManager(Settings.Value, Console.WriteLine, state);

            // Print settings
            _weaponDataManager?.DebugLog($"Settings:");
            _weaponDataManager?.DebugLog($"  - PluginFilter: {Settings.Value.PluginFilter}");
            _weaponDataManager?.DebugLog($"  - WACCFMaterialTiers: {Settings.Value.WACCFMaterialTiers}");
            _weaponDataManager?.DebugLog($"  - StalhrimStaggerBonus: {Settings.Value.StalhrimStaggerBonus}");
            _weaponDataManager?.DebugLog($"  - StalhrimDamageBonus: {Settings.Value.StalhrimDamageBonus}");
            _weaponDataManager?.DebugLog($"  - SpecialWeaponsMod: {Settings.Value.SpecialWeaponsMod}");
            _weaponDataManager?.DebugLog($"  - BoundWeaponParsing: {Settings.Value.BoundWeaponParsing}");

            // Resolve weapon setting overlaps
            Action<string> logger = _weaponDataManager != null
                ? (message) => _weaponDataManager.DebugLog(message)
                : Console.WriteLine;
            var overlapResolver = new WeaponSettingOverlapResolver(Settings.Value, logger);
            Console.WriteLine("Checking settings integrity...");
            overlapResolver.ResolveOverlaps();
            Console.WriteLine("Settings integrity check complete.");

            // Set the resolved settings in WeaponDataManager
            _weaponDataManager?.SetSortedSettings(overlapResolver.GetSortedSettings());

            // Get the list of plugins to include
            var pluginIncludeList = Settings.Value.PluginIncludeList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Get the list of plugins to exclude
            var pluginExcludeList = Settings.Value.PluginExcludeList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Get the list of ignored weapon form keys
            var ignoredWeaponFormKeys = Settings.Value.IgnoredWeaponFormKeys
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            _weaponDataManager?.DebugLog($"Raw ignored weapons string: '{Settings.Value.IgnoredWeaponFormKeys}'");

            Console.WriteLine("Plugin Processing Settings:");
            Console.WriteLine($"Filter Mode: {Settings.Value.PluginFilter}");
            _weaponDataManager?.DebugLog("Plugin Include List:");
            if (WeaponDataManager.DebugMode)
            {
                foreach (var plugin in pluginIncludeList)
                {
                    _weaponDataManager?.DebugLog($"     {plugin}");
                }
                _weaponDataManager?.DebugLog("Plugin Exclude List:");
                foreach (var plugin in pluginExcludeList)
                {
                    _weaponDataManager?.DebugLog($"     {plugin}");
                }
            }

            // Get all available plugins in load order
            var availablePlugins = state.LoadOrder.PriorityOrder
                .Select(mod => mod.ModKey.FileName.String)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Check for missing plugins if we're in include mode
            if (Settings.Value.PluginFilter == PluginFilter.IncludePlugins)
            {
                var missingPlugins = pluginIncludeList.Where(p => !availablePlugins.Contains(p)).ToList();
                if (missingPlugins.Any())
                {
                    Console.WriteLine("WARNING: The following plugins were listed for inclusion but could not be found:");
                    foreach (var plugin in missingPlugins)
                    {
                        Console.WriteLine($"     {plugin}");
                    }
                    Console.WriteLine();
                }
            }

            Console.WriteLine("Processing the following plugins:");
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginExcludeList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginIncludeList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (shouldProcess)
                {
                    Console.WriteLine($"     {modGetter.ModKey.FileName}");
                }
            }
            Console.WriteLine();

            // Verify form keys in special_weapons.json
            VerifyFormKeys(state);

            // Process weapons from plugins
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginExcludeList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginIncludeList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (!shouldProcess) continue;

                _weaponDataManager?.DebugLog($"========================================");
                Console.WriteLine($"Processing mod: {modGetter.ModKey.FileName}");
                _weaponDataManager?.DebugLog($"========================================");

                // Process each weapon from the current mod
                foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()
                    .Where(w => w.FormKey.ModKey == modGetter.ModKey))
                {
                    _weaponDataManager?.DebugLog($"------------------------------------------");
                    _weaponDataManager?.DebugLog($"Processing weapon: {weapon.EditorID}");
                    _weaponDataManager?.DebugLog($"------------------------------------------");
                    bool isSpecialWeapon = _weaponDataManager?.IsSpecialWeapon(weapon) ?? false;
                    _weaponDataManager?.DebugLog($"Is EDID {weapon.EditorID} a Special Weapon: {isSpecialWeapon}");
                    bool isProcessNonPlayable = weapon.FormKey.ModKey.FileName.ToString().Equals("ccbgssse025-advdsgs.esm", StringComparison.OrdinalIgnoreCase);

                    // Check if weapon is bound
                    bool isBound = (weapon.EditorID?.Contains("bound", StringComparison.OrdinalIgnoreCase) ?? false) ||
                                  (weapon.Name?.String?.Contains("bound", StringComparison.OrdinalIgnoreCase) ?? false);

                    _weaponDataManager?.DebugLog($"Is EDID {weapon.EditorID} from mod with non playable weapons that should be processed: {isProcessNonPlayable}");

                    // Skip if weapon is not playable and it is not from mod ccbgssse025-advdsgs.esm and is not bound
                    if (weapon.Data?.Flags.HasFlag(WeaponData.Flag.NonPlayable) == true && !isSpecialWeapon && !isProcessNonPlayable && !isBound)
                    {
                        _weaponDataManager?.DebugLog($"Skipping non-playable weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Skip if weapon uses a template
                    if (weapon.Template?.FormKey != null &&
                        !weapon.Template.FormKey.IsNull &&
                        weapon.Template.FormKey.ToString() != "Null" &&
                        !isSpecialWeapon)
                    {
                        _weaponDataManager?.DebugLog($"Skipping template weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Check if weapon should be ignored
                    var formKeyString = weapon.FormKey.ToString();
                    if (formKeyString != null && ignoredWeaponFormKeys.Contains(formKeyString) && !isSpecialWeapon)
                    {
                        _weaponDataManager?.DebugLog($"Weapon {weapon.EditorID} is in ignoredWeaponFormKeys list");
                        continue;
                    }

                    // Get weapon setting key
                    var weaponSettingKey = _weaponDataManager?.GetWeaponSettingKey(weapon, state.LinkCache);
                    if (weaponSettingKey == null)
                    {
                        _weaponDataManager?.DebugLog($"Warning: Could not determine weapon setting key for {weapon.EditorID}");
                        continue;
                    }

                    // Process weapon based on if it is a special weapon or not
                    if (isSpecialWeapon)
                    {
                        _weaponDataManager?.DebugLog($"Processing special weapon: {weapon.EditorID}");
                        ProcessSpecialWeapon(weapon, state, weaponSettingKey);
                    }
                    else
                    {
                        _weaponDataManager?.DebugLog($"Processing weapon: {weapon.EditorID}");
                        ProcessWeapon(weapon, state, weaponSettingKey);
                    }
                }
            }
        }
        private static void ProcessSpecialWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, string weaponSettingKey)
        {
            if (weapon == null || state == null || string.IsNullOrEmpty(weaponSettingKey))
            {
                _weaponDataManager?.DebugLog("Invalid parameters in ProcessSpecialWeapon");
                return;
            }

            // Get weapon settings from the appropriate category
            WeaponSettings? settings = null;
            foreach (var category in Settings.Value.GetAllWeaponCategories())
            {
                if (category.Weapons.TryGetValue(weaponSettingKey, out var weaponSettings))
                {
                    settings = weaponSettings;
                    break;
                }
            }

            if (settings == null)
            {
                _weaponDataManager?.DebugLog($"{weaponSettingKey} is not enabled in settings");
                return;
            }

            // Get weapon keywords
            var weaponKeywords = _weaponDataManager?.GetWeaponKeywords(weapon, state.LinkCache) ?? new List<string>();

            // Get default weapon stats
            var defaultStats = _weaponDataManager?.GetDefaultWeaponStats(weaponKeywords);
            if (defaultStats == null)
            {
                _weaponDataManager?.DebugLog($"No matching default weapon stats found for {weapon.EditorID}");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
            {
                _weaponDataManager?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Calculate offsets between current weapon stats and default stats            
            int damageOffset = weaponOverride.BasicStats.Damage - (Settings.Value.WACCFMaterialTiers ? defaultStats.DamageWaccf : defaultStats.Damage);
            decimal speedOffset = (decimal)weaponOverride.Data.Speed - defaultStats.Speed;
            decimal reachOffset = (decimal)weaponOverride.Data.Reach - defaultStats.Reach;
            decimal staggerOffset = (decimal)weaponOverride.Data.Stagger - defaultStats.Stagger;
            int criticalDamageOffset = weaponOverride.Critical.Damage - defaultStats.CriticalDamage;
            decimal criticalDamageChanceMultiplierOffset = (decimal)weaponOverride.Critical.PercentMult - defaultStats.CriticalChanceMult;

            // Apply stats with offsets
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + damageOffset);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed + (float)speedOffset);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach + (float)reachOffset);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger + (float)staggerOffset);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageChanceMultiplier + (float)criticalDamageChanceMultiplierOffset);
            decimal settingsCriticalDamage = Math.Floor((decimal)settings.CriticalDamageMultiplier * ((settings.Damage / 2m) + (decimal)settings.CriticalDamageOffset));
            weaponOverride.Critical.Damage = (ushort)Math.Max(0, settingsCriticalDamage + criticalDamageOffset);

            _weaponDataManager?.DebugLog($"Successfully processed special weapon: {weapon.EditorID}");
            _weaponDataManager?.DebugLog($"Final stats:");
            _weaponDataManager?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponDataManager?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponDataManager?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponDataManager?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
            _weaponDataManager?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponDataManager?.DebugLog($"- Critical Damage Chance Multiplier: {weaponOverride.Critical.PercentMult}");
        }

        private static void ProcessWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, string weaponSettingKey)
        {
            if (weapon == null || state == null || string.IsNullOrEmpty(weaponSettingKey))
            {
                _weaponDataManager?.DebugLog("Invalid parameters in ProcessWeapon");
                return;
            }

            // Get weapon settings from the appropriate category
            WeaponSettings? settings = null;
            foreach (var category in Settings.Value.GetAllWeaponCategories())
            {
                if (category.Weapons.TryGetValue(weaponSettingKey, out var weaponSettings))
                {
                    settings = weaponSettings;
                    break;
                }
            }

            if (settings == null)
            {
                _weaponDataManager?.DebugLog($"{weaponSettingKey} is not enabled in settings");
                return;
            }

            // Handle bound weapons based on parsing mode
            int? damageOffset = null;
            bool isBound = (weapon.EditorID?.Contains("bound", StringComparison.OrdinalIgnoreCase) ?? false) ||
                          (weapon.Name?.String?.Contains("bound", StringComparison.OrdinalIgnoreCase) ?? false);
            if (isBound)
            {
                switch (Settings.Value.BoundWeaponParsing)
                {
                    case BoundWeaponParsing.IgnoreWeapon:
                        _weaponDataManager?.DebugLog($"Skipping bound weapon: {weapon.EditorID}");
                        return;

                    case BoundWeaponParsing.FromSettings:
                        bool isMysticBound = weapon.EditorID?.Contains("mystic", StringComparison.OrdinalIgnoreCase) ?? false;
                        damageOffset = isMysticBound
                            ? settings.BoundMysticWeaponAdditionalDamage
                            : settings.BoundWeaponAdditionalDamage;
                        break;

                    case BoundWeaponParsing.CalculateFromMods:
                        // Get current damage and keywords
                        var currentDamage = weapon.BasicStats?.Damage ?? 0;
                        var keywords = weapon.Keywords?.Select(k => k.FormKey.ToString()) ?? Enumerable.Empty<string>();

                        // Find matching default damage
                        var defaultDamage = _weaponDataManager?.GetLoadedDefaultWeaponStatsData()
                            .FirstOrDefault(d => keywords.Contains(d.Keyword));

                        if (defaultDamage == null)
                        {
                            _weaponDataManager?.DebugLog($"No matching default damage found for bound weapon {weapon.EditorID}");
                            return;
                        }

                        // Calculate damage offset
                        damageOffset = currentDamage - defaultDamage.Damage;
                        _weaponDataManager?.DebugLog($"Calculated damage offset for bound weapon {weapon.EditorID}: {damageOffset}");
                        break;
                }
            }
            else
            {
                damageOffset = _weaponDataManager?.GetDamageOffset(weapon, state.LinkCache, Settings.Value.WACCFMaterialTiers);
            }

            if (damageOffset == null)
            {
                _weaponDataManager?.DebugLog($"Warning: Could not determine damage offset for {weapon.EditorID}. Skipping.");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
            {
                _weaponDataManager?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Get variant settings
            var (additionalDamage, additionalReach, additionalSpeed, additionalStagger,
                 additionalCriticalDamageOffset, additionalCriticalDamageChanceMultiplier,
                 additionalCriticalDamageMultiplier) = _weaponDataManager?.GetVariantStats(weapon, state.LinkCache)
                ?? (0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);

            // Apply stats
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + damageOffset.Value + additionalDamage);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed + additionalSpeed);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach + additionalReach);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger + additionalStagger);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageChanceMultiplier + additionalCriticalDamageChanceMultiplier);

            // Check for Stalhrim weapons and apply stagger bonus if WACCF material tiers are disabled
            if (!Settings.Value.WACCFMaterialTiers && weaponOverride.Data.Stagger > 0)
            {
                bool isStalhrim = weapon.Keywords?.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false) ?? false;
                _weaponDataManager?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Stagger: {weaponOverride.Data.Stagger}");
                if (isStalhrim)
                {
                    weaponOverride.Data.Stagger = (float)Math.Max(0m, (decimal)weaponOverride.Data.Stagger + 0.1m);
                    _weaponDataManager?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}. Stagger: {weaponOverride.Data.Stagger}");
                }
            }

            // Check for Stalhrim weapons and apply stagger bonus if WACCF material tiers are disabled
            if (weaponOverride.Data.Stagger > 0)
            {
                bool isStalhrim = weapon.Keywords?.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false) ?? false;
                _weaponDataManager?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Stagger: {weaponOverride.Data.Stagger}");
                if (isStalhrim)
                {
                    weaponOverride.Data.Stagger = (float)Math.Max(0m, (decimal)weaponOverride.Data.Stagger + (decimal)Settings.Value.StalhrimStaggerBonus);
                    _weaponDataManager?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}. Stagger: {weaponOverride.Data.Stagger}");
                }
            }

            // Check for Stalhrim weapons that are either war axes or maces and add damage bonus
            if (weapon.Keywords != null)
            {
                bool isStalhrim = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false);
                bool isWarAxe = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeWarAxe") ?? false);
                bool isMace = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeMace") ?? false);

                if (isStalhrim && (isWarAxe || isMace))
                {
                    _weaponDataManager?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Is War Axe: {isWarAxe}. Is Mace: {isMace}. Damage: {weaponOverride.BasicStats.Damage}");
                    weaponOverride.BasicStats.Damage += (ushort)Settings.Value.StalhrimDamageBonus;
                    _weaponDataManager?.DebugLog($"Applied Stalhrim damage bonus to {weapon.EditorID}. Damage: {weaponOverride.BasicStats.Damage}");
                }
            }

            // if material is glass and waccf is enabled, apply glass critical damage bonus of 0,5
            decimal waccfCriticalDamageBonus = 0;
            if (Settings.Value.WACCFMaterialTiers && weapon.Keywords != null)
            {
                bool isGlass = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapMaterialGlass") ?? false);
                bool isDaedric = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapMaterialDaedric") ?? false);
                bool isFalmerHoned = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapMaterialFalmerHoned") ?? false);
                bool isWarAxe = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeWarAxe") ?? false);
                bool isWarHammer = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeWarhammer") ?? false);
                if (isGlass || (isDaedric && isWarHammer) || (isFalmerHoned && isWarAxe))
                {
                    waccfCriticalDamageBonus = 0.5m;
                }
            }

            // Apply critical damage stats
            decimal halfDamage = (decimal)weaponOverride.BasicStats.Damage / 2m;
            decimal criticalDamageOffset = (decimal)settings.CriticalDamageOffset + (decimal)additionalCriticalDamageOffset + waccfCriticalDamageBonus;
            decimal criticalDamageMultiplier = (decimal)settings.CriticalDamageMultiplier + (decimal)additionalCriticalDamageMultiplier;
            decimal criticalDamage = Math.Floor(criticalDamageMultiplier * (halfDamage + criticalDamageOffset));
            weaponOverride.Critical.Damage = (ushort)Math.Max(0, Math.Min(ushort.MaxValue, (int)criticalDamage));

            _weaponDataManager?.DebugLog($"Successfully processed weapon: {weapon.EditorID}");
            _weaponDataManager?.DebugLog($"Final stats:");
            _weaponDataManager?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponDataManager?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponDataManager?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponDataManager?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
            _weaponDataManager?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponDataManager?.DebugLog($"- Critical Damage Chance Multiplier: {weaponOverride.Critical.PercentMult}");
        }

        /// <summary>
        /// Verifies that all form keys in the special_weapons.json file are correct by looking up each editor ID.
        /// </summary>
        private static void VerifyFormKeys(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Verifying form keys in special_weapons.json...");

            try
            {
                var specialWeaponsPath = state.RetrieveInternalFile("special_weapons.json");
                string jsonContent = File.ReadAllText(specialWeaponsPath);
                var specialWeapons = System.Text.Json.JsonSerializer.Deserialize<List<SpecialWeaponData>>(jsonContent) ?? new List<SpecialWeaponData>();

                _weaponDataManager?.DebugLog($"Loaded {specialWeapons.Count} special weapons from JSON file.");

                // Lists to store valid and invalid entries
                var validEntries = new List<(string EditorID, string FormKey)>();
                var invalidEntries = new List<(string EditorID, string FormKey, string Error)>();
                var suggestedFormKeys = new List<(string EditorID, string CurrentFormKey, string SuggestedFormKey)>();

                // Check each special weapon
                foreach (var specialWeapon in specialWeapons)
                {
                    if (string.IsNullOrEmpty(specialWeapon.EditorID))
                    {
                        invalidEntries.Add((specialWeapon.EditorID ?? "null", specialWeapon.FormKey ?? "null", "EditorID is null or empty"));
                        continue;
                    }

                    if (string.IsNullOrEmpty(specialWeapon.FormKey))
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey ?? "null", "FormKey is null or empty"));
                        continue;
                    }

                    // Try to parse the form key
                    if (!FormKey.TryFactory(specialWeapon.FormKey, out var formKey))
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Invalid form key format"));
                        continue;
                    }

                    try
                    {
                        // Look up the weapon by form key
                        var weapon = state.LinkCache.Resolve<IWeaponGetter>(formKey);

                        if (weapon == null)
                        {
                            // Try to look up the weapon by editor ID in original definitions
                            var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                                .WinningOverrides()
                                .FirstOrDefault(w => w.EditorID == specialWeapon.EditorID);

                            if (originalWeapon != null)
                            {
                                var suggestedFormKey = $"{originalWeapon.FormKey.ID:X6}:{originalWeapon.FormKey.ModKey.FileName}";
                                suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                            }
                            else
                            {
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                            }
                            continue;
                        }

                        // Check if the editor ID matches
                        if (weapon.EditorID != specialWeapon.EditorID)
                        {
                            // Get the original definition of this weapon
                            var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                                .WinningOverrides()
                                .FirstOrDefault(w => w.FormKey == weapon.FormKey);

                            if (originalWeapon != null && originalWeapon.EditorID == specialWeapon.EditorID)
                            {
                                // The original version matches our editor ID, so this is valid
                                validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                            }
                            else
                            {
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey,
                                    $"EditorID mismatch: expected '{specialWeapon.EditorID}', found '{weapon.EditorID}' in current version. " +
                                    $"Original version has EditorID '{originalWeapon?.EditorID ?? "unknown"}'"));
                            }
                            continue;
                        }

                        // If we get here, the form key is valid
                        validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                    }
                    catch (Mutagen.Bethesda.Plugins.Exceptions.MissingRecordException)
                    {
                        // Try to look up the weapon by editor ID in original definitions
                        var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                            .WinningOverrides()
                            .FirstOrDefault(w => w.EditorID == specialWeapon.EditorID);

                        if (originalWeapon != null)
                        {
                            var suggestedFormKey = $"{originalWeapon.FormKey.ID:X6}:{originalWeapon.FormKey.ModKey.FileName}";
                            suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                        }
                        else
                        {
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                        }
                    }
                }

                // Print results
                _weaponDataManager?.DebugLog("=== VALID FORM KEYS ===");
                if (validEntries.Count == 0)
                {
                    _weaponDataManager?.DebugLog("No valid form keys found.");
                }
                else
                {
                    foreach (var entry in validEntries)
                    {
                        _weaponDataManager?.DebugLog($"Valid: {entry.EditorID}: {entry.FormKey}");
                    }
                }

                Console.WriteLine("=== INVALID FORM KEYS ===");
                if (invalidEntries.Count == 0)
                {
                    Console.WriteLine("No invalid form keys found.");
                }
                else
                {
                    foreach (var entry in invalidEntries)
                    {
                        Console.WriteLine($"Invalid: {entry.EditorID}: {entry.FormKey} - {entry.Error}");
                    }
                }

                Console.WriteLine($"\nSummary: {validEntries.Count} valid, {invalidEntries.Count} invalid form keys.");

                // Print suggested form keys
                if (suggestedFormKeys.Count > 0)
                {
                    Console.WriteLine("\n=== SUGGESTED FORM KEY CORRECTIONS ===");
                    Console.WriteLine("The following entries have incorrect form keys. Here are the suggested corrections:");
                    foreach (var suggestion in suggestedFormKeys)
                    {
                        Console.WriteLine($"  {suggestion.EditorID}: {suggestion.CurrentFormKey} -> {suggestion.SuggestedFormKey}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error verifying form keys: {ex.Message}");
            }
        }
    }
}
