using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using System;
using System.Linq;
using System.Collections.Generic;

namespace Weapon_Mod_Synergy
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Weapon_Mod_Synergy.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {            
            /* // Print all weapon settings
            var weaponProperties = typeof(Settings).GetProperties()
                .Where(p => p.PropertyType == typeof(WeaponSettings));
            foreach (var prop in weaponProperties)
            {
                var value = prop.GetValue(Settings.Value) as WeaponSettings;
                if (value != null)
                {
                    PrintWeaponSettings($"{prop.Name} (iron)", value);
                }
            } */
            
            // Get the list of plugins to include or exclude
            var pluginList = Settings.Value.PluginList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            Console.WriteLine("Plugin Processing Settings:");
            Console.WriteLine($"Filter Mode: {Settings.Value.PluginFilter}");
            Console.WriteLine("Plugin List:");
            foreach (var plugin in pluginList)
            {
                Console.WriteLine($"  - {plugin}");
            }
            Console.WriteLine();

            // Get all available plugins in load order
            var availablePlugins = state.LoadOrder.PriorityOrder
                .Select(mod => mod.ModKey.FileName.String)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Check for missing plugins if we're in include mode
            if (Settings.Value.PluginFilter == PluginFilter.IncludePlugins)
            {
                var missingPlugins = pluginList.Where(p => !availablePlugins.Contains(p)).ToList();
                if (missingPlugins.Any())
                {
                    Console.WriteLine("WARNING: The following plugins were listed for inclusion but could not be found:");
                    foreach (var plugin in missingPlugins)
                    {
                        Console.WriteLine($"  - {plugin}");
                    }
                    Console.WriteLine();
                }
            }

            Console.WriteLine("Processing the following plugins:");
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (shouldProcess)
                {
                    Console.WriteLine($"  - {modGetter.ModKey.FileName}");
                }
            }
            Console.WriteLine();

            // Build dictionary of enabled weapon types
            var enabledWeaponTypes = new Dictionary<string, WeaponSettings>();
            
            // Mapping from weapon type keywords to settings property names
            var weaponTypeToSettingsMap = new Dictionary<string, string>
            {
                { "WeapTypeDagger", "Dagger" },
                { "WeapTypeSword", "Sword" },
                { "WeapTypeWarAxe", "WarAxe" },
                { "WeapTypeMace", "Mace" },
                { "WeapTypeGreatsword", "Greatsword" },
                { "WeapTypeBattleaxe", "Battleaxe" },
                { "WeapTypeWarhammer", "Warhammer" },
                { "WeapTypeTanto", "Tanto" },
                { "WeapTypeWakizashi", "Wakizashi" },
                { "WeapTypeKatana", "Katana" },
                { "WeapTypeDaiKatana", "DaiKatana" },
                { "ShWeapTypeShortsword", "Shortsword" },
                { "ShWeapTypeHatchet", "Hatchet" },
                { "ShWeapTypeClub", "Club" },
                { "ShWeapTypeMaul", "Maul" },
                { "ShWeapTypeShortspear", "Shortspear" },
                { "ShWeapTypeHalberd", "HeavyArmoryHalberd" },
                { "WeapTypeHalberd", "AnimatedArmouryHalberd" },
                { "ShWeapTypeSpear", "Spear2h" },
                { "ShWeapTypeQuarterStaff", "HeavyArmoryQuarterstaff" },
                { "WeapTypeQtrStaff", "AnimatedArmouryQuarterstaff" },
                { "ShWeapTypeGlaive", "Glaive" },
                { "ShWeapTypeTrident", "Trident" },
                { "WeapTypeClaw", "Claw" },
                { "WeapTypeRapier", "Rapier" },
                { "WeapTypeWhip", "Whip" },
                { "WeapTypePike", "Pike" },
                { "WeapTypeJavelin", "Javelin" },
                { "WeapTypeSpear", "Spear1h" },
                { "ShWeapTypeLongMace", "LongMace" }
            };
            
            // Add enabled weapon types to the dictionary
            foreach (var kvp in weaponTypeToSettingsMap)
            {
                var weaponType = kvp.Key;
                var settingsPropertyName = kvp.Value;
                
                // Check if this weapon type should be processed
                bool shouldProcess = settingsPropertyName switch
                {
                    "Dagger" => Settings.Value.ProcessDaggers,
                    "Tanto" => Settings.Value.ProcessTantos,
                    "Claw" => Settings.Value.ProcessClaws,
                    "Javelin" => Settings.Value.ProcessJavelins,
                    "Rapier" => Settings.Value.ProcessRapiers,
                    "Wakizashi" => Settings.Value.ProcessWakizashis,
                    "Shortsword" => Settings.Value.ProcessShortswords,
                    "Spear1h" => Settings.Value.ProcessSpears1h,
                    "Sword" => Settings.Value.ProcessSwords,
                    "Katana" => Settings.Value.ProcessKatanas,
                    "Hatchet" => Settings.Value.ProcessHatchets,
                    "Club" => Settings.Value.ProcessClubs,
                    "Shortspear" => Settings.Value.ProcessShortspears,
                    "Whip" => Settings.Value.ProcessWhips,
                    "WarAxe" => Settings.Value.ProcessWarAxes,
                    "Mace" => Settings.Value.ProcessMaces,
                    "HeavyArmoryQuarterstaff" => Settings.Value.ProcessHeavyArmoryQuarterstaffs,
                    "AnimatedArmouryQuarterstaff" => Settings.Value.ProcessAnimatedArmouryQuarterstaffs,
                    "Maul" => Settings.Value.ProcessMauls,
                    "Spear2h" => Settings.Value.ProcessSpears2h,
                    "Pike" => Settings.Value.ProcessPikes,
                    "Glaive" => Settings.Value.ProcessGlaives,
                    "Trident" => Settings.Value.ProcessTridents,
                    "Greatsword" => Settings.Value.ProcessGreatswords,
                    "DaiKatana" => Settings.Value.ProcessDaiKatanas,
                    "HeavyArmoryHalberd" => Settings.Value.ProcessHeavyArmoryHalberds,
                    "AnimatedArmouryHalberd" => Settings.Value.ProcessAnimatedArmouryHalberds,
                    "LongMace" => Settings.Value.ProcessLongMaces,
                    "Battleaxe" => Settings.Value.ProcessBattleaxes,
                    "Warhammer" => Settings.Value.ProcessWarhammers,
                    _ => false
                };
                
                if (shouldProcess)
                {
                    // Get the settings using reflection
                    var settingsProperty = typeof(Settings).GetProperty(settingsPropertyName);
                    if (settingsProperty != null)
                    {
                        var settings = settingsProperty.GetValue(Settings.Value) as WeaponSettings;
                        if (settings != null)
                        {
                            // Add to enabled weapon types
                            enabledWeaponTypes.Add(weaponType, settings);
                        }
                    }
                }
            }

            var relevantWeapons = new HashSet<IFormLinkGetter<IWeaponGetter>>();
            
            // First pass - collect all relevant weapons based on plugin filter
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (!shouldProcess) continue;

                var weapons = modGetter.Mod?.Weapons;
                if (weapons == null) continue;

                // Process each weapon
                foreach (var weapon in weapons)
                {
                    if (weapon.Keywords == null) continue;

                    var weaponKeywords = weapon.Keywords
                        .Select(k => state.LinkCache.TryResolve(k, out var resolvedKeyword) ? resolvedKeyword.EditorID : k.FormKey.ToString())
                        .ToList();

                    // Check if weapon has any of our target keywords
                    var matchingKeyword = weapon.Keywords
                        .Select(k => state.LinkCache.TryResolve(k, out var resolvedKeyword) ? resolvedKeyword.EditorID : null)
                        .FirstOrDefault(k => k != null && enabledWeaponTypes.ContainsKey(k));

                    if (matchingKeyword != null)
                    {
                        var settings = enabledWeaponTypes[matchingKeyword];
                        Console.WriteLine($"Processing weapon {weapon.EditorID} with type {matchingKeyword}");
                        
                        // Skip weapons with templates
                        if (weapon.Template?.FormKey != null && !weapon.Template.FormKey.IsNull)
                        {
                            Console.WriteLine("  Skipped: Has template");
                            continue;
                        }
                        
                        // Check if this weapon matches any of our enabled weapon types
                        string? weaponType = WeaponHelper.GetWeaponType(weapon, state.LinkCache, Settings.Value.WACCFMaterialTiers);
                        Console.WriteLine(weaponType);
                        if (weaponType == null)
                        {
                            Console.WriteLine("  Skipped: No matching weapon type found");
                            continue;
                        }

                        if (!enabledWeaponTypes.ContainsKey(weaponType))
                        {
                            Console.WriteLine($"  Skipped: Weapon type {weaponType} not enabled in settings");
                            continue;
                        }
                        
                        relevantWeapons.Add(weapon.ToLink());
                    }
                }
            }

            // Second pass - get winning overrides for all relevant weapons
            foreach (var weaponLink in relevantWeapons)
            {
                if (!weaponLink.TryResolve(state.LinkCache, out var weaponGetter)) continue;
                
                if (string.IsNullOrEmpty(weaponGetter.EditorID))
                {
                    Console.WriteLine($"Skipped weapon: Missing EditorID");
                    continue;
                }
                
                Console.WriteLine($"  Processing weapon: {weaponGetter.EditorID}");
                
                var keywords = weaponGetter.Keywords?
                    .Select(k => k.TryResolve(state.LinkCache, out var keyword) ? keyword.EditorID : k.FormKey.ToString())
                    .Where(k => k != null)
                    .ToList() ?? new List<string?>();
                
                Console.WriteLine($"  Keywords: {string.Join(", ", keywords)}");
                    
                string? weaponType = WeaponHelper.GetWeaponType(weaponGetter, state.LinkCache, Settings.Value.WACCFMaterialTiers);
                Console.WriteLine($"  Detected weapon type: {weaponType ?? "null"}");
                if (weaponType == null)
                {
                    Console.WriteLine($"Error processing weapon {weaponGetter.EditorID}: Could not determine weapon type");
                    continue;
                }

                string? weaponGrip = WeaponHelper.GetWeaponGrip(weaponGetter, state.LinkCache);
                Console.WriteLine($"  Detected weapon grip: {weaponGrip ?? "null"}");
                if (weaponGrip == null)
                {
                    Console.WriteLine($"Error processing weapon {weaponGetter.EditorID}: Could not determine grip type");
                    continue;
                }

                string? material = WeaponHelper.GetWeaponMaterial(weaponGetter, state.LinkCache, Settings.Value.WACCFMaterialTiers);
                Console.WriteLine($"  Detected material: {material ?? "null"}");
                if (material == null)
                {
                    Console.WriteLine($"Error processing weapon {weaponGetter.EditorID}: Could not determine material");
                    continue;
                }
                
                // Get the weapon settings based on its type
                if (!enabledWeaponTypes.TryGetValue(weaponType, out var weaponSettings))
                {
                    Console.WriteLine($"Error processing weapon {weaponGetter.EditorID}: Weapon type {weaponType} not found in settings");
                    continue;
                }

                // Create a new weapon record in the patch
                var weapon = state.PatchMod.Weapons.GetOrAddAsOverride(weaponGetter);
                if (weapon == null)
                {
                    Console.WriteLine($"Error processing weapon {weaponGetter.EditorID}: Could not create override record");
                    continue;
                }

                // Make sure we have a Data object
                weapon.Data ??= new();
                
                // Make sure we have BasicStats object
                weapon.BasicStats ??= new();
                
                // Update the weapon's reach
                weapon.Data.Reach = weaponSettings.Reach;
                
                // Update speed and stagger
                weapon.Data.Speed = weaponSettings.Speed;
                weapon.Data.Stagger = weaponSettings.Stagger;
                
                // Add stalhrim stagger bonus if WACCF tiers are not enabled and base stagger is greater than 0
                if (!Settings.Value.WACCFMaterialTiers && material == "DLC2WeaponMaterialStalhrim" && weaponSettings.Stagger > 0)
                {
                    weapon.Data.Stagger += 0.1f;
                }
                
                // Get the damage offset based on material
                int damageOffset = WeaponHelper.GetDamageOffset(weaponGetter, state.LinkCache, material, Settings.Value.WACCFMaterialTiers, weaponGrip);
                ushort totalDamage = (ushort)(weaponSettings.Damage + damageOffset);
                weapon.BasicStats.Damage = totalDamage;
                
                // Calculate and set critical damage
                Console.WriteLine($"  Starting critical damage calculation for {weaponGetter.EditorID}");
                weapon.Critical ??= new();
                
                // First calculate the critical damage offset using iron weapon values
                Console.WriteLine($"  Calculating iron base critical damage for {weaponGetter.EditorID}");
                ushort ironBaseCriticalDamage;
                if (weaponSettings.UseFloorDivision)
                {
                    ironBaseCriticalDamage = (ushort)(weaponSettings.Damage / 2);
                    Console.WriteLine($"  Iron base critical damage (floor division): {ironBaseCriticalDamage} (from base damage {weaponSettings.Damage})");
                }
                else
                {
                    ironBaseCriticalDamage = (ushort)Math.Round(weaponSettings.Damage / 2.0);
                    Console.WriteLine($"  Iron base critical damage (round): {ironBaseCriticalDamage} (from base damage {weaponSettings.Damage})");
                }
                
                // Calculate the offset by comparing iron's base critical with desired critical
                Console.WriteLine($"  Calculating critical damage offset for {weaponGetter.EditorID}");
                ushort criticalDamageOffset = (ushort)(weaponSettings.CriticalDamage - ironBaseCriticalDamage);
                Console.WriteLine($"  Critical damage offset: {criticalDamageOffset} (desired critical {weaponSettings.CriticalDamage} - iron base {ironBaseCriticalDamage})");

                // Calculate the weapon's base critical damage
                Console.WriteLine($"  Calculating weapon base critical damage for {weaponGetter.EditorID}");
                ushort weaponBaseCriticalDamage;
                if (weaponSettings.UseFloorDivision)
                {
                    weaponBaseCriticalDamage = (ushort)Math.Floor((double)weapon.BasicStats.Damage / 2);
                }
                else
                {
                    weaponBaseCriticalDamage = (ushort)Math.Round((double)weapon.BasicStats.Damage / 2, MidpointRounding.AwayFromZero);
                }
                Console.WriteLine($"  Weapon base critical damage: {weaponBaseCriticalDamage}");
                
                // Apply the offset to get the final critical damage
                Console.WriteLine($"  Calculating final critical damage for {weaponGetter.EditorID}");
                ushort totalCriticalDamage = (ushort)(weaponBaseCriticalDamage + criticalDamageOffset);
                Console.WriteLine($"  Final critical damage: {totalCriticalDamage} (base {weaponBaseCriticalDamage} + offset {criticalDamageOffset})");
                
                // Set the critical damage and multiplier
                weapon.Critical.Damage = totalCriticalDamage;
                weapon.Critical.PercentMult = weaponSettings.CriticalDamageMultiplier;
                Console.WriteLine($"  Critical damage calculation completed for {weaponGetter.EditorID}");
            }
        }
        
        private static void PrintWeaponSettings(string weaponName, WeaponSettings settings)
        {
            Console.WriteLine($"{weaponName} Settings:");
            Console.WriteLine($"  Damage: {settings.Damage}");
            Console.WriteLine($"  Reach: {settings.Reach}");
            Console.WriteLine($"  Speed: {settings.Speed}");
            Console.WriteLine($"  Stagger: {settings.Stagger}");
            Console.WriteLine($"  Critical Damage: {settings.CriticalDamage}");
            Console.WriteLine();
        }
    }
}
