using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Order;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using Mutagen.Bethesda.Plugins.Binary.Headers;
#pragma warning disable CA1416 

namespace Weapon_Mod_Synergy
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;
        private static WeaponHelper? _weaponHelper;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Weapon_Mod_Synergy.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {

            // Initialize enabled weapon types from settings
            var enabledWeaponTypes = new Dictionary<string, WeaponSettings>();

            // Get all properties of type WeaponSettings from the Settings class
            var settingsProperties = typeof(Settings).GetProperties()
                .Where(p => p.PropertyType == typeof(WeaponSettings));

            foreach (var prop in settingsProperties)
            {
                var settings = prop.GetValue(Settings.Value) as WeaponSettings;
                if (settings != null)
                {
                    // Use the property name as the weapon type
                    enabledWeaponTypes.Add(prop.Name, settings);
                    _weaponHelper?.DebugLog($"Enabled weapon type: {prop.Name}");
                }
                else
                {
                    _weaponHelper?.DebugLog($"Warning: Could not get weapon settings for {prop.Name}");
                }
            }

            // Create WeaponHelper instance
            _weaponHelper = new WeaponHelper(enabledWeaponTypes, Console.WriteLine, state);

            // Get the list of plugins to include or exclude
            var pluginList = Settings.Value.PluginList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Get the list of ignored weapon form keys
            var ignoredWeaponFormKeys = Settings.Value.IgnoredWeaponFormKeys
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            _weaponHelper?.DebugLog($"Raw ignored weapons string: '{Settings.Value.IgnoredWeaponFormKeys}'");

            Console.WriteLine("Plugin Processing Settings:");
            Console.WriteLine($"Filter Mode: {Settings.Value.PluginFilter}");
            Console.WriteLine("Plugin List:");
            foreach (var plugin in pluginList)
            {
                Console.WriteLine($"     {plugin}");
            }
            Console.WriteLine();

            // Get all available plugins in load order
            var availablePlugins = state.LoadOrder.PriorityOrder
                .Select(mod => mod.ModKey.FileName.String)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            // Check for missing plugins if we're in include mode
            if (Settings.Value.PluginFilter == PluginFilter.IncludePlugins)
            {
                var missingPlugins = pluginList.Where(p => !availablePlugins.Contains(p)).ToList();
                if (missingPlugins.Any())
                {
                    Console.WriteLine("WARNING: The following plugins were listed for inclusion but could not be found:");
                    foreach (var plugin in missingPlugins)
                    {
                        Console.WriteLine($"     {plugin}");
                    }
                    Console.WriteLine();
                }
            }

            Console.WriteLine("Processing the following plugins:");
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (shouldProcess)
                {
                    Console.WriteLine($"     {modGetter.ModKey.FileName}");
                }
            }
            Console.WriteLine();

            // Verify form keys in special_weapons.json
            if (WeaponHelper.DebugMode)
                VerifyFormKeys(state);

            // Process weapons from plugins
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                var shouldProcess = Settings.Value.PluginFilter switch
                {
                    PluginFilter.AllPlugins => true,
                    PluginFilter.ExcludePlugins => !pluginList.Contains(modGetter.ModKey.FileName.String),
                    PluginFilter.IncludePlugins => pluginList.Contains(modGetter.ModKey.FileName.String),
                    _ => true
                };

                if (!shouldProcess) continue;

                _weaponHelper?.DebugLog($"========================================");
                Console.WriteLine($"Processing mod: {modGetter.ModKey.FileName}");
                _weaponHelper?.DebugLog($"========================================");

                // Process each weapon from the current mod
                foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()
                    .Where(w => w.FormKey.ModKey == modGetter.ModKey))
                {
                    _weaponHelper?.DebugLog($"------------------------------------------");
                    _weaponHelper?.DebugLog($"Processing weapon: {weapon.EditorID}");
                    _weaponHelper?.DebugLog($"------------------------------------------");
                    bool isSpecialWeapon = _weaponHelper?.IsSpecialWeapon(weapon) ?? false;
                    _weaponHelper?.DebugLog($"Is EDID {weapon.EditorID} a Special Weapon: {isSpecialWeapon}");
                    bool isProcessNonPlayable = weapon.FormKey.ModKey.FileName.ToString().Equals("ccbgssse025-advdsgs.esm", StringComparison.OrdinalIgnoreCase);
                    _weaponHelper?.DebugLog($"Is EDID {weapon.EditorID} from mod with non playable weapons that should be processed: {isProcessNonPlayable}");
                    // Skip if weapon is not playable and it is not from mod ccbgssse025-advdsgs.esm
                    if (weapon.Data?.Flags.HasFlag(WeaponData.Flag.NonPlayable) == true && !isSpecialWeapon && !isProcessNonPlayable)
                    {
                        _weaponHelper?.DebugLog($"Skipping non-playable weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Skip if weapon uses a template
                    if (weapon.Template?.FormKey != null &&
                        !weapon.Template.FormKey.IsNull &&
                        weapon.Template.FormKey.ToString() != "Null" &&
                        !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Skipping template weapon: {weapon.EditorID}");
                        continue;
                    }

                    // Check if weapon should be ignored
                    var formKeyString = weapon.FormKey.ToString();
                    if (formKeyString != null && ignoredWeaponFormKeys.Contains(formKeyString) && !isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Weapon {weapon.EditorID} is in ignoredWeaponFormKeys list");
                        continue;
                    }

                    // Get weapon setting key
                    var weaponSettingKey = _weaponHelper?.GetWeaponSettingKey(weapon, state.LinkCache);
                    if (weaponSettingKey == null)
                    {
                        _weaponHelper?.DebugLog($"Warning: Could not determine weapon setting key for {weapon.EditorID}");
                        continue;
                    }

                    // Get weapon settings
                    if (!enabledWeaponTypes.TryGetValue(weaponSettingKey, out var settings))
                    {
                        _weaponHelper?.DebugLog($"{weaponSettingKey} is not enabled in settings");
                        continue;
                    }
                    _weaponHelper?.DebugLog($"Match found for weapon {weapon.EditorID} with type {weaponSettingKey}");
                    _weaponHelper?.DebugLog($"Weapon settings for {weaponSettingKey}:");
                    _weaponHelper?.DebugLog($"- Base Damage (iron): {settings.Damage}");
                    _weaponHelper?.DebugLog($"- Reach: {settings.Reach}");
                    _weaponHelper?.DebugLog($"- Speed: {settings.Speed}");
                    _weaponHelper?.DebugLog($"- Stagger: {settings.Stagger}");
                    _weaponHelper?.DebugLog($"- Critical Damage offset: {settings.CriticalDamageOffset}");
                    _weaponHelper?.DebugLog($"- Critical Damage chance multiplier: {settings.CriticalDamageChanceMultiplier}");
                    _weaponHelper?.DebugLog($"- Critical Damage multiplier: {settings.CriticalDamageMultiplier}");

                    // Process weapon based on if it is a special weapon or not
                    if (isSpecialWeapon)
                    {
                        _weaponHelper?.DebugLog($"Processing special weapon: {weapon.EditorID}");
                        ProcessSpecialWeapon(weapon, state, settings);
                    }
                    else
                    {
                        _weaponHelper?.DebugLog($"Processing weapon: {weapon.EditorID}");
                        ProcessWeapon(weapon, state, settings);
                    }
                }
            }
        }

        private static void ProcessSpecialWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, WeaponSettings settings)
        {
            var specialWeapons = _weaponHelper?.GetLoadedSpecialWeapons();
            if (specialWeapons == null) { _weaponHelper?.DebugLog($"ERROR: No special weapons data loaded. Skipping special weapon checks."); }
            else
            {
                foreach (var specialWeapon in specialWeapons)
                {
                    if (string.IsNullOrEmpty(specialWeapon.FormKey)) { _weaponHelper?.DebugLog($"ERROR: Special weapon {specialWeapon.EditorID} has no form key. Skipping."); continue; }

                    if (FormKey.TryFactory(specialWeapon.FormKey, out var formKey) && weapon.FormKey == formKey)
                    {
                        _weaponHelper?.DebugLog($"Found by form key: {weapon.FormKey}");

                        // Create a copy of the weapon for modification
                        var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
                        if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
                        {
                            _weaponHelper?.DebugLog($"ERROR: Could not create override for {weapon.EditorID}. Skipping.");
                            continue;
                        }

                        // Apply special weapon offsets
                        int specialDamageOffset = specialWeapon.DamageOffset ?? 0;
                        float speedOffset = specialWeapon.SpeedOffset ?? 0;
                        float reachOffset = specialWeapon.ReachOffset ?? 0;
                        float staggerOffset = specialWeapon.StaggerOffset ?? 0;
                        int criticalDamageOffsett = specialWeapon.CriticalDamageOffset ?? 0;
                        float criticalDamageChanceMultiplierOffset = specialWeapon.CriticalDamageChanceMultiplierOffset ?? 0;

                        _weaponHelper?.DebugLog($"Applying special weapon offsets for {weapon.EditorID}:");
                        _weaponHelper?.DebugLog($"  - Damage Offset: {specialDamageOffset}");
                        _weaponHelper?.DebugLog($"  - Speed Offset: {speedOffset}");
                        _weaponHelper?.DebugLog($"  - Reach Offset: {reachOffset}");
                        _weaponHelper?.DebugLog($"  - Stagger Offset: {staggerOffset}");
                        _weaponHelper?.DebugLog($"  - Critical Damage Offset: {criticalDamageOffsett}");
                        _weaponHelper?.DebugLog($"  - Critical Damage Chance Multiplier Offset: {criticalDamageChanceMultiplierOffset}");

                        if (Settings.Value.WACCFMaterialTiers)
                        {
                            if (specialWeapon.DamageOffsetWaccf != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF damage offset: {specialDamageOffset}");
                            }
                            if (specialWeapon.SpeedOffsetWaccf != null)
                            {
                                speedOffset = specialWeapon.SpeedOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF speed offset: {speedOffset}");
                            }
                            if (specialWeapon.ReachOffsetWaccf != null)
                            {
                                reachOffset = specialWeapon.ReachOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF reach offset: {reachOffset}");
                            }
                            if (specialWeapon.StaggerOffsetWaccf != null)
                            {
                                staggerOffset = specialWeapon.StaggerOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF stagger offset: {staggerOffset}");
                            }
                            if (specialWeapon.CriticalDamageOffsetWaccf != null)
                            {
                                criticalDamageOffsett = specialWeapon.CriticalDamageOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF critical damage offset: {criticalDamageOffsett}");
                            }
                            if (specialWeapon.CriticalDamageChanceMultiplierOffsetWaccf != null)
                            {
                                criticalDamageChanceMultiplierOffset = specialWeapon.CriticalDamageChanceMultiplierOffsetWaccf.Value;
                                _weaponHelper?.DebugLog($"Using WACCF critical damage chance multiplier offset: {criticalDamageChanceMultiplierOffset}");
                            }
                        }

                        if (Settings.Value.Artificer)
                        {
                            if (specialWeapon.DamageOffsetArtificer != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer damage offset: {specialDamageOffset}");
                            }
                            if (specialWeapon.SpeedOffsetArtificer != null)
                            {
                                speedOffset = specialWeapon.SpeedOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer speed offset: {speedOffset}");
                            }
                            if (specialWeapon.ReachOffsetArtificer != null)
                            {
                                reachOffset = specialWeapon.ReachOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer reach offset: {reachOffset}");
                            }
                            if (specialWeapon.StaggerOffsetArtificer != null)
                            {
                                staggerOffset = specialWeapon.StaggerOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer stagger offset: {staggerOffset}");
                            }
                            if (specialWeapon.CriticalDamageOffsetArtificer != null)
                            {
                                criticalDamageOffsett = specialWeapon.CriticalDamageOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer critical damage offset: {criticalDamageOffsett}");
                            }
                            if (specialWeapon.CriticalDamageChanceMultiplierOffsetArtificer != null)
                            {
                                criticalDamageChanceMultiplierOffset = specialWeapon.CriticalDamageChanceMultiplierOffsetArtificer.Value;
                                _weaponHelper?.DebugLog($"Using Artificer critical damage chance multiplier offset: {criticalDamageChanceMultiplierOffset}");
                            }
                        }

                        if (Settings.Value.Mysticism)
                        {
                            if (specialWeapon.DamageOffsetMysticism != null)
                            {
                                specialDamageOffset = specialWeapon.DamageOffsetMysticism.Value;
                                _weaponHelper?.DebugLog($"Using Mysticism damage offset: {specialDamageOffset}");
                            }
                        }

                        weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + specialDamageOffset);
                        weaponOverride.Data.Speed = Math.Max(0f, settings.Speed + speedOffset);
                        weaponOverride.Data.Reach = Math.Max(0f, settings.Reach + reachOffset);
                        weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger + staggerOffset);
                        weaponOverride.Critical.Damage = Math.Max((ushort)0, (ushort)Math.Floor(criticalDamageOffsett + (float)weaponOverride.BasicStats.Damage / 2.0));
                        weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageChanceMultiplier + criticalDamageChanceMultiplierOffset);

                        _weaponHelper?.DebugLog($"Successfully processed special weapon: {weapon.EditorID}");
                        _weaponHelper?.DebugLog($"Final stats:");
                        _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
                        _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
                        _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
                        _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
                        _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
                        _weaponHelper?.DebugLog($"- Critical Damage Chance Multiplier: {weaponOverride.Critical.PercentMult}");
                        break;
                    }
                }
            }
        }

        private static void ProcessWeapon(IWeaponGetter weapon, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, WeaponSettings settings)
        {
            // Get damage offset and check if weapon is special
            int? damageOffset = _weaponHelper?.GetDamageOffset(weapon, state.LinkCache, Settings.Value.WACCFMaterialTiers);
            if (damageOffset == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not determine damage offset for {weapon.EditorID}. Skipping.");
                return;
            }

            // Create a copy of the weapon for modification
            var weaponOverride = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
            if (weaponOverride?.Data == null || weaponOverride.BasicStats == null || weaponOverride.Critical == null)
            {
                _weaponHelper?.DebugLog($"Warning: Could not create override for {weapon.EditorID}");
                return;
            }

            // Apply stats
            weaponOverride.BasicStats.Damage = (ushort)Math.Max(0, settings.Damage + damageOffset.Value);
            weaponOverride.Data.Speed = Math.Max(0f, settings.Speed);
            weaponOverride.Data.Reach = Math.Max(0f, settings.Reach);
            weaponOverride.Data.Stagger = Math.Max(0f, settings.Stagger);
            weaponOverride.Critical.PercentMult = Math.Max(0f, settings.CriticalDamageChanceMultiplier);

            // Check for Stalhrim weapons and apply stagger bonus if WACCF material tiers are disabled
            if (!Settings.Value.WACCFMaterialTiers && weaponOverride.Data.Stagger > 0)
            {
                bool isStalhrim = weapon.Keywords?.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false) ?? false;
                _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Stagger: {weaponOverride.Data.Stagger}");
                if (isStalhrim)
                {
                    weaponOverride.Data.Stagger += 0.1f;
                    _weaponHelper?.DebugLog($"Applied Stalhrim stagger bonus to {weapon.EditorID}. Stagger: {weaponOverride.Data.Stagger}");
                }
            }

            // Check for Stalhrim weapons that are either war axes or maces and add damage bonus
            if (weapon.Keywords != null)
            {
                bool isStalhrim = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("DLC2WeaponMaterialStalhrim") ?? false);
                bool isWarAxe = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeWarAxe") ?? false);
                bool isMace = weapon.Keywords.Any(k => k.TryResolve(state.LinkCache)?.EditorID?.Contains("WeapTypeMace") ?? false);

                if (isStalhrim && (isWarAxe || isMace))
                {
                    _weaponHelper?.DebugLog($"Has DLC2WeaponMaterialStalhrim: {isStalhrim}. Is War Axe: {isWarAxe}. Is Mace: {isMace}. Damage: {weaponOverride.BasicStats.Damage}");
                    weaponOverride.BasicStats.Damage += 1;
                    _weaponHelper?.DebugLog($"Applied Stalhrim damage bonus to {weapon.EditorID}. Damage: {weaponOverride.BasicStats.Damage}");
                }
            }

            ushort criticalDamage = (ushort)Math.Floor(settings.CriticalDamageMultiplier * (settings.CriticalDamageOffset + (float)weaponOverride.BasicStats.Damage / 2));
            // Apply critical damage stats
            weaponOverride.Critical.Damage = Math.Max((ushort)0, criticalDamage);

            _weaponHelper?.DebugLog($"Successfully processed weapon: {weapon.EditorID}");
            _weaponHelper?.DebugLog($"Final stats:");
            _weaponHelper?.DebugLog($"- Damage: {weaponOverride.BasicStats.Damage}");
            _weaponHelper?.DebugLog($"- Speed: {weaponOverride.Data.Speed}");
            _weaponHelper?.DebugLog($"- Reach: {weaponOverride.Data.Reach}");
            _weaponHelper?.DebugLog($"- Stagger: {weaponOverride.Data.Stagger}");
            _weaponHelper?.DebugLog($"- Critical Damage: {weaponOverride.Critical.Damage}");
            _weaponHelper?.DebugLog($"- Critical Damage Chance Multiplier: {weaponOverride.Critical.PercentMult}");
        }

        /// <summary>
        /// Verifies that all form keys in the special_weapons.json file are correct by looking up each editor ID.
        /// </summary>
        private static void VerifyFormKeys(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Verifying form keys in special_weapons.json...");

            try
            {
                var specialWeaponsPath = state.RetrieveInternalFile("special_weapons.json");
                string jsonContent = File.ReadAllText(specialWeaponsPath);
                var specialWeapons = System.Text.Json.JsonSerializer.Deserialize<List<SpecialWeaponData>>(jsonContent) ?? new List<SpecialWeaponData>();

                Console.WriteLine($"Loaded {specialWeapons.Count} special weapons from JSON file.");

                // Lists to store valid and invalid entries
                var validEntries = new List<(string EditorID, string FormKey)>();
                var invalidEntries = new List<(string EditorID, string FormKey, string Error)>();
                var suggestedFormKeys = new List<(string EditorID, string CurrentFormKey, string SuggestedFormKey)>();

                // Check each special weapon
                foreach (var specialWeapon in specialWeapons)
                {
                    if (string.IsNullOrEmpty(specialWeapon.EditorID))
                    {
                        invalidEntries.Add((specialWeapon.EditorID ?? "null", specialWeapon.FormKey ?? "null", "EditorID is null or empty"));
                        continue;
                    }

                    if (string.IsNullOrEmpty(specialWeapon.FormKey))
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey ?? "null", "FormKey is null or empty"));
                        continue;
                    }

                    // Try to parse the form key
                    if (!FormKey.TryFactory(specialWeapon.FormKey, out var formKey))
                    {
                        invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Invalid form key format"));
                        continue;
                    }

                    try
                    {
                        // Look up the weapon by form key
                        var weapon = state.LinkCache.Resolve<IWeaponGetter>(formKey);

                        if (weapon == null)
                        {
                            // Try to look up the weapon by editor ID in original definitions
                            var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                                .WinningOverrides()
                                .FirstOrDefault(w => w.EditorID == specialWeapon.EditorID);

                            if (originalWeapon != null)
                            {
                                var suggestedFormKey = $"{originalWeapon.FormKey.ID:X6}:{originalWeapon.FormKey.ModKey.FileName}";
                                suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                            }
                            else
                            {
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                            }
                            continue;
                        }

                        // Check if the editor ID matches
                        if (weapon.EditorID != specialWeapon.EditorID)
                        {
                            // Get the original definition of this weapon
                            var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                                .WinningOverrides()
                                .FirstOrDefault(w => w.FormKey == weapon.FormKey);

                            if (originalWeapon != null && originalWeapon.EditorID == specialWeapon.EditorID)
                            {
                                // The original version matches our editor ID, so this is valid
                                validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                            }
                            else
                            {
                                invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey,
                                    $"EditorID mismatch: expected '{specialWeapon.EditorID}', found '{weapon.EditorID}' in current version. " +
                                    $"Original version has EditorID '{originalWeapon?.EditorID ?? "unknown"}'"));
                            }
                            continue;
                        }

                        // If we get here, the form key is valid
                        validEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey));
                    }
                    catch (Mutagen.Bethesda.Plugins.Exceptions.MissingRecordException)
                    {
                        // Try to look up the weapon by editor ID in original definitions
                        var originalWeapon = state.LoadOrder.ListedOrder.Weapon()
                            .WinningOverrides()
                            .FirstOrDefault(w => w.EditorID == specialWeapon.EditorID);

                        if (originalWeapon != null)
                        {
                            var suggestedFormKey = $"{originalWeapon.FormKey.ID:X6}:{originalWeapon.FormKey.ModKey.FileName}";
                            suggestedFormKeys.Add((specialWeapon.EditorID, specialWeapon.FormKey, suggestedFormKey));
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, $"Record not found in load order. Suggested form key: {suggestedFormKey}"));
                        }
                        else
                        {
                            invalidEntries.Add((specialWeapon.EditorID, specialWeapon.FormKey, "Record not found in load order"));
                        }
                    }
                }

                // Print results
                Console.WriteLine("\n=== VALID FORM KEYS ===");
                if (validEntries.Count == 0)
                {
                    Console.WriteLine("No valid form keys found.");
                }
                else
                {
                    foreach (var entry in validEntries)
                    {
                        Console.WriteLine($"Valid: {entry.EditorID}: {entry.FormKey}");
                    }
                }

                Console.WriteLine("\n=== INVALID FORM KEYS ===");
                if (invalidEntries.Count == 0)
                {
                    Console.WriteLine("No invalid form keys found.");
                }
                else
                {
                    foreach (var entry in invalidEntries)
                    {
                        Console.WriteLine($"Invalid: {entry.EditorID}: {entry.FormKey} - {entry.Error}");
                    }
                }

                Console.WriteLine($"\nSummary: {validEntries.Count} valid, {invalidEntries.Count} invalid form keys.");

                // Print suggested form keys
                if (suggestedFormKeys.Count > 0)
                {
                    Console.WriteLine("\n=== SUGGESTED FORM KEY CORRECTIONS ===");
                    Console.WriteLine("The following entries have incorrect form keys. Here are the suggested corrections:");
                    foreach (var suggestion in suggestedFormKeys)
                    {
                        Console.WriteLine($"  {suggestion.EditorID}: {suggestion.CurrentFormKey} -> {suggestion.SuggestedFormKey}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error verifying form keys: {ex.Message}");
            }
        }
    }
}
